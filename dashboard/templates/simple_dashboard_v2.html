<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Target Monitor Pro - Enterprise Stock Monitoring</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
    <style>
        :root {
            /* Modern dark theme with improved contrast and visual hierarchy */

            /* Backgrounds - Distinct layers */
            --bg-primary: #0a0e14;        /* Darker base */
            --bg-secondary: #151a21;      /* Distinct from primary */
            --bg-elevated: #1c2128;       /* Clear elevation */
            --bg-card: #1f2937;           /* Card surfaces */
            --bg-card-hover: #252d3a;     /* Hover state */

            /* Borders - More visible */
            --border-subtle: #2d3748;     /* Main borders */
            --border-default: #374151;    /* Interactive elements */
            --border-accent: #4b5563;     /* Focused/active */

            /* Accent Colors - Vibrant & Purposeful */
            --accent-primary: #60a5fa;    /* Main blue (brighter) */
            --accent-primary-hover: #3b82f6;
            --accent-secondary: #8b5cf6;  /* Purple for special features */
            --accent-tertiary: #06b6d4;   /* Cyan for info */

            /* Semantic Colors */
            --success: #10b981;           /* Green - in stock */
            --success-bg: rgba(16, 185, 129, 0.1);
            --success-border: rgba(16, 185, 129, 0.3);

            --warning: #f59e0b;           /* Amber - limited stock */
            --warning-bg: rgba(245, 158, 11, 0.1);
            --warning-border: rgba(245, 158, 11, 0.3);

            --danger: #ef4444;            /* Red - out of stock */
            --danger-bg: rgba(239, 68, 68, 0.1);
            --danger-border: rgba(239, 68, 68, 0.3);

            --info: #06b6d4;              /* Cyan - info */
            --info-bg: rgba(6, 182, 212, 0.1);
            --info-border: rgba(6, 182, 212, 0.3);

            /* Text - Clear hierarchy */
            --text-primary: #f9fafb;      /* Headlines */
            --text-secondary: #d1d5db;    /* Body text */
            --text-tertiary: #9ca3af;     /* Labels */
            --text-muted: #6b7280;        /* Subtle text */

            /* Shadows - Depth */
            --shadow-sm: 0 1px 3px rgba(0, 0, 0, 0.5);
            --shadow-md: 0 4px 6px rgba(0, 0, 0, 0.4);
            --shadow-lg: 0 10px 20px rgba(0, 0, 0, 0.6);
            --shadow-xl: 0 20px 40px rgba(0, 0, 0, 0.7);

            /* Gradients */
            --gradient-primary: linear-gradient(135deg, #60a5fa 0%, #3b82f6 100%);
            --gradient-success: linear-gradient(135deg, #10b981 0%, #059669 100%);
            --gradient-premium: linear-gradient(135deg, #8b5cf6 0%, #6366f1 100%);

            /* Typography Scale */
            --text-display: 3.5rem;       /* 56px - Hero metric values */
            --text-display-weight: 700;
            --text-h1: 1.75rem;           /* 28px - Section titles */
            --text-h2: 1.25rem;           /* 20px - Card titles */
            --text-h3: 1rem;              /* 16px - Subsections */
            --text-body: 0.9375rem;       /* 15px - Main text */
            --text-body-sm: 0.875rem;     /* 14px - Secondary text */
            --text-sm: 0.8125rem;         /* 13px - Labels */
            --text-xs: 0.75rem;           /* 12px - Captions */

            /* Line heights */
            --leading-tight: 1.25;
            --leading-normal: 1.5;
            --leading-relaxed: 1.75;

            /* Spacing System */
            --space-1: 4px;
            --space-2: 8px;
            --space-3: 12px;
            --space-4: 16px;
            --space-5: 20px;
            --space-6: 24px;
            --space-8: 32px;
            --space-10: 40px;
            --space-12: 48px;
            --space-16: 64px;
            --space-20: 80px;

            /* Font Families */
            --font-primary: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            --font-mono: 'JetBrains Mono', 'SF Mono', Consolas, monospace;
            --font-display: 'Inter', system-ui, sans-serif;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: var(--font-primary);
            background: var(--bg-primary);
            color: var(--text-primary);
            line-height: var(--leading-normal);
            min-height: 100vh;
            overflow-x: hidden;
            font-size: var(--text-body);
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 2rem;
        }

        .header {
            background: linear-gradient(135deg, var(--secondary-bg) 0%, var(--card-bg) 100%);
            border-bottom: 1px solid var(--border-color);
            padding: 1.5rem 0;
            position: sticky;
            top: 0;
            z-index: 100;
            backdrop-filter: blur(10px);
            margin: -2rem -2rem 2rem -2rem;
        }

        .header-content {
            max-width: 1400px;
            margin: 0 auto;
            padding: 0 2rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .header h1 {
            font-size: 1.5rem;
            font-weight: 600;
            background: linear-gradient(135deg, var(--accent-color), var(--success-color));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .header-stats {
            display: flex;
            gap: 2rem;
            font-size: 0.875rem;
        }

        .header-stat {
            display: flex;
            flex-direction: column;
            align-items: center;
            opacity: 0.8;
        }

        .header-stat-label {
            color: var(--text-muted);
            margin-bottom: 0.25rem;
        }

        .header-stat-value {
            font-weight: 600;
            font-size: 1.1rem;
        }

        .status-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 1.5rem;
            margin-bottom: 2rem;
        }

        .status-card {
            background: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 1.5rem;
            position: relative;
            overflow: hidden;
            transition: all 0.3s ease;
        }

        .status-card:hover {
            transform: translateY(-4px);
            box-shadow: 0 8px 25px rgba(88, 166, 255, 0.15);
            border-color: var(--accent-color);
        }

        .status-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, var(--accent-color), var(--success-color));
        }

        .status-card.warning::before {
            background: var(--warning-color);
        }

        .status-card.danger::before,
        .status-card.error::before {
            background: var(--danger-color);
        }

        .status-card.success::before {
            background: var(--success-color);
        }

        .status-card-title {
            color: var(--text-secondary);
            font-size: 0.875rem;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 1rem;
        }

        .status-card-value {
            font-size: 2.5rem;
            font-weight: 700;
            line-height: 1;
            margin-bottom: 0.5rem;
        }

        .status-card-subtitle {
            color: var(--text-muted);
            font-size: 0.875rem;
        }

        .status-card.success .status-card-value {
            color: var(--success-color);
        }

        .status-card.error .status-card-value,
        .status-card.danger .status-card-value {
            color: var(--danger-color);
        }

        .status-card.warning .status-card-value {
            color: var(--warning-color);
        }

        /* Alert styling */
        .alert {
            padding: 1rem 1.5rem;
            border-radius: 8px;
            margin-bottom: 1.5rem;
            border-left: 4px solid;
            background: rgba(63, 185, 80, 0.1);
            border-left-color: var(--success-color);
            color: var(--success-color);
        }

        .alert-title {
            font-weight: 600;
            margin-bottom: 0.5rem;
        }

        /* Backwards compatibility for old class names */
        .status-card h2 {
            color: var(--text-secondary);
            font-size: 0.875rem;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 1rem;
        }

        .status-card .value {
            font-size: 2.5rem;
            font-weight: 700;
            line-height: 1;
            margin-bottom: 0.5rem;
        }

        .status-card .subtitle {
            color: var(--text-muted);
            font-size: 0.875rem;
        }

        .status-card.success .value {
            color: var(--success-color);
        }

        .status-card.error .value {
            color: var(--danger-color);
        }

        .status-card.warning .value {
            color: var(--warning-color);
        }

        .section {
            background: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            margin-bottom: 2rem;
            overflow: hidden;
        }

        .section-header {
            padding: 1.5rem 2rem;
            border-bottom: 1px solid var(--border-color);
            background: var(--secondary-bg);
        }

        .section-title {
            font-size: 1.125rem;
            font-weight: 600;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .section-content {
            padding: 2rem;
        }

        .clear-logs-btn {
            background: var(--danger-color);
            color: white;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 6px;
            font-size: 0.875rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            display: inline-flex;
            align-items: center;
            gap: 0.375rem;
        }

        .clear-logs-btn:hover {
            background: var(--danger-light);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(239, 68, 68, 0.3);
        }

        .clear-logs-btn:active {
            transform: translateY(0);
        }

        .section-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1.5rem 2rem;
            border-bottom: 1px solid var(--border-color);
        }

        .table-container {
            overflow-x: auto;
            border-radius: 8px;
            border: 1px solid var(--border-color);
        }

        table {
            width: 100%;
            border-collapse: collapse;
            background: var(--secondary-bg);
        }

        th {
            background: var(--primary-bg);
            padding: 1rem;
            text-align: left;
            color: var(--text-secondary);
            font-weight: 500;
            font-size: 0.875rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            border-bottom: 1px solid var(--border-color);
        }

        td {
            padding: 0.75rem 1rem;
            border-bottom: 1px solid var(--border-color);
            vertical-align: middle;
        }

        tr:hover {
            background: var(--card-bg);
        }

        tr:last-child td {
            border-bottom: none;
        }

        .product-row {
            display: grid;
            grid-template-columns: 80px 1fr 120px 100px 120px;
            gap: 1.5rem;
            padding: 1.5rem;
            border-bottom: 1px solid var(--border-color);
            align-items: center;
            transition: all 0.15s ease;
            position: relative;
        }

        .product-row:last-child {
            border-bottom: none;
        }

        .product-row:hover {
            background: var(--secondary-bg);
        }

        .product-row::before {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            width: 4px;
            background: var(--border-light);
        }

        .product-row.in-stock::before {
            background: var(--success-color);
        }

        .product-row.out-of-stock::before {
            background: var(--danger-color);
        }

        .product-image-small {
            width: 60px;
            height: 60px;
            border-radius: 6px;
            object-fit: contain;
            background: var(--secondary-bg);
            padding: 0.5rem;
            border: 1px solid var(--border-color);
        }

        .product-name-cell {
            font-size: 0.9rem;
            font-weight: 500;
            color: var(--text-primary);
            line-height: 1.4;
            overflow: hidden;
        }

        .product-tcin-cell {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.8rem;
            color: var(--text-secondary);
            background: var(--secondary-bg);
            padding: 0.5rem 0.75rem;
            border-radius: 4px;
            text-align: center;
            border: 1px solid var(--border-color);
        }

        .product-status-cell {
            text-align: center;
        }

        .badge {
            display: inline-flex;
            align-items: center;
            padding: 0.0625rem 0.25rem;
            border-radius: 2px;
            font-size: 0.5rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.1px;
            gap: 0.0625rem;
            white-space: nowrap;
        }

        .badge.enabled {
            background: rgba(63, 185, 80, 0.15);
            color: var(--success-color);
            border: 1px solid rgba(63, 185, 80, 0.3);
        }

        .badge.disabled {
            background: rgba(248, 81, 73, 0.15);
            color: var(--danger-color);
            border: 1px solid rgba(248, 81, 73, 0.3);
        }

        .badge.in-stock {
            background: rgba(63, 185, 80, 0.35);
            color: #22c55e;
            border: 2px solid rgba(63, 185, 80, 0.7);
            font-weight: 700;
            box-shadow: 0 0 8px rgba(63, 185, 80, 0.3);
        }

        .badge.out-of-stock {
            background: rgba(248, 81, 73, 0.35);
            color: #ef4444;
            border: 2px solid rgba(248, 81, 73, 0.7);
            font-weight: 700;
            box-shadow: 0 0 8px rgba(248, 81, 73, 0.3);
        }

        .badge.unknown {
            background: rgba(139, 148, 158, 0.15);
            color: var(--text-secondary);
            border: 1px solid rgba(139, 148, 158, 0.3);
        }

        .badge.preorder {
            background: rgba(88, 166, 255, 0.15);
            color: var(--accent-color);
            border: 1px solid rgba(88, 166, 255, 0.3);
        }

        .badge.ready {
            background: linear-gradient(135deg, rgba(16, 185, 129, 0.2), rgba(5, 150, 105, 0.2));
            color: #10b981;
            border: 1px solid rgba(16, 185, 129, 0.4);
            font-weight: 600;
            box-shadow: 0 2px 4px rgba(16, 185, 129, 0.1);
        }

        .badge.attempting {
            background: linear-gradient(135deg, rgba(251, 146, 60, 0.25), rgba(249, 115, 22, 0.25));
            color: #f97316;
            border: 1px solid rgba(251, 146, 60, 0.5);
            font-weight: 600;
            box-shadow: 0 2px 4px rgba(251, 146, 60, 0.2);
            animation: pulse 1s ease-in-out infinite;
        }

        .badge.cooldown {
            background: rgba(139, 148, 158, 0.15);
            color: var(--text-secondary);
            border: 1px solid rgba(139, 148, 158, 0.3);
        }

        .badge.failed {
            background: rgba(248, 81, 73, 0.15);
            color: var(--danger-color);
            border: 1px solid rgba(248, 81, 73, 0.3);
        }

        .badge.purchased {
            background: rgba(88, 166, 255, 0.15);
            color: var(--accent-color);
            border: 1px solid rgba(88, 166, 255, 0.3);
        }

        /* Backwards compatibility */
        .status-badge {
            display: inline-flex;
            align-items: center;
            padding: 0.0625rem 0.25rem;
            border-radius: 2px;
            font-size: 0.5rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.1px;
            gap: 0.0625rem;
            white-space: nowrap;
        }

        .status-badge.in-stock {
            background: rgba(63, 185, 80, 0.15);
            color: var(--success-color);
            border: 1px solid rgba(63, 185, 80, 0.3);
        }

        .status-badge.out-of-stock {
            background: rgba(248, 81, 73, 0.15);
            color: var(--danger-color);
            border: 1px solid rgba(248, 81, 73, 0.3);
        }

        .status-badge.unknown {
            background: rgba(139, 148, 158, 0.15);
            color: var(--text-secondary);
            border: 1px solid rgba(139, 148, 158, 0.3);
        }

        .product-action-cell {
            text-align: center;
        }

        .btn-small {
            padding: 0.375rem 0.75rem;
            font-size: 0.75rem;
            border-radius: 6px;
        }

        .activity-section {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-height: 400px;
            max-height: 500px;
        }

        .activity-wrapper {
            background: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 1.5rem;
            box-shadow: var(--shadow);
            display: flex;
            flex-direction: column;
            flex: 1;
            min-height: 0;
        }

        .product-card {
            background: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: 16px;
            padding: 1.5rem;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: var(--shadow);
            position: relative;
            overflow: hidden;
        }

        .product-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: var(--accent-color);
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .product-card:hover {
            transform: translateY(-6px);
            box-shadow: var(--shadow-xl);
            border-color: var(--border-light);
        }

        .product-card:hover::before {
            opacity: 1;
        }

        .product-card.in-stock::before {
            background: var(--success-color);
            opacity: 1;
        }

        .product-card.out-of-stock::before {
            background: var(--danger-color);
            opacity: 0.5;
        }

        .product-image {
            margin-bottom: 1.5rem;
            text-align: center;
            position: relative;
        }

        .product-image img {
            max-width: 100%;
            max-height: 150px;
            width: auto;
            height: auto;
            object-fit: contain;
            border-radius: 12px;
            background: var(--secondary-bg);
            padding: 1rem;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: var(--shadow-sm);
        }

        .product-image img:hover {
            transform: scale(1.08);
            box-shadow: var(--shadow-lg);
        }

        .product-name {
            font-size: 1.125rem;
            font-weight: 600;
            margin-bottom: 0.5rem;
            color: var(--text-primary);
            line-height: 1.4;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
            min-height: 2.8rem;
        }

        .product-tcin {
            color: var(--text-muted);
            font-size: 0.75rem;
            margin-bottom: 1rem;
            font-family: 'JetBrains Mono', 'SF Mono', Monaco, 'Cascadia Code', 'Roboto Mono', Consolas, 'Courier New', monospace;
            font-weight: 500;
            background: var(--secondary-bg);
            padding: 0.25rem 0.5rem;
            border-radius: 6px;
            display: inline-block;
        }

        .badge {
            display: inline-flex;
            align-items: center;
            padding: 0.5rem 1rem;
            border-radius: 50px;
            font-size: 0.875rem;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            gap: 0.5rem;
            margin-bottom: 1rem;
            transition: all 0.2s ease;
            box-shadow: var(--shadow-sm);
        }

        .badge.in-stock {
            background: linear-gradient(135deg, var(--success-color), var(--success-light));
            color: white;
            box-shadow: 0 4px 14px 0 rgba(16, 185, 129, 0.39);
        }

        .badge.out-of-stock {
            background: linear-gradient(135deg, var(--danger-color), var(--danger-light));
            color: white;
            box-shadow: 0 4px 14px 0 rgba(239, 68, 68, 0.39);
        }

        .badge.unknown {
            background: var(--secondary-bg);
            color: var(--text-secondary);
            border: 1px solid var(--border-color);
        }

        .badge.preorder {
            background: linear-gradient(135deg, var(--accent-color), var(--accent-light));
            color: white;
            box-shadow: 0 4px 14px 0 rgba(59, 130, 246, 0.39);
        }

        .product-actions {
            margin-top: 1rem;
            display: flex;
            gap: 0.75rem;
        }

        .btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 0.5rem 1rem;
            border-radius: 6px;
            font-size: 0.875rem;
            font-weight: 500;
            text-decoration: none;
            border: none;
            cursor: pointer;
            transition: all 0.2s ease;
            gap: 0.5rem;
        }

        .btn-primary {
            background: var(--accent-color);
            color: white;
        }

        .btn-primary:hover {
            background: #4493e0;
            transform: translateY(-1px);
        }

        .btn-outline {
            background: transparent;
            color: var(--accent-color);
            border: 1px solid var(--accent-color);
        }

        .btn-outline:hover {
            background: var(--accent-color);
            color: white;
        }

        .btn-small {
            padding: 0.375rem 0.75rem;
            font-size: 0.75rem;
            border-radius: 6px;
        }

        .footer {
            text-align: center;
            margin-top: 0.5rem;
            padding: 0.5rem 0;
            border-top: 1px solid var(--border-color);
            color: var(--text-muted);
        }

        .footer p {
            margin-bottom: 0.25rem;
            font-size: 0.75rem;
        }

        .refresh-indicator {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.75rem;
            color: var(--text-secondary);
            margin-bottom: 0.5rem;
        }

        .countdown {
            font-weight: 600;
            color: var(--accent-color);
            min-width: 2rem;
            text-align: center;
        }

        .refreshing {
            color: var(--warning-color);
            animation: pulse 1s ease-in-out infinite;
        }

        .loading {
            text-align: center;
            padding: 2rem 1rem;
            color: var(--text-secondary);
        }

        .loading .spinner {
            display: inline-block;
            width: 32px;
            height: 32px;
            border: 3px solid var(--border-color);
            border-top: 3px solid var(--accent-color);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 0.5rem;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }

        .refreshing {
            color: var(--warning-light) !important;
            animation: pulse 1s ease-in-out infinite;
        }

        .refresh-indicator {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            font-size: 0.875rem;
            color: var(--text-secondary);
            margin-bottom: 1rem;
            font-weight: 500;
        }

        .sticky-timer {
            display: none;
        }

        .sticky-timer:hover {
            box-shadow: var(--shadow-xl);
        }

        .sticky-timer .countdown {
            color: var(--accent-color);
            font-weight: 700;
            font-size: 1rem;
            min-width: 2rem;
            text-align: center;
        }

        .sticky-timer.refreshing {
            color: var(--warning-color);
            animation: pulse 1s ease-in-out infinite;
        }

        .log-container {
            max-height: 400px;
            overflow-y: auto;
            border-radius: 8px;
            border: 1px solid var(--border-color);
            background: var(--primary-bg);
        }

        .log-entry {
            font-family: 'SF Mono', Monaco, 'Cascadia Code', 'Roboto Mono', Consolas, 'Courier New', monospace;
            font-size: 0.8125rem;
            padding: 0.75rem 1rem;
            border-left: 3px solid var(--border-color);
            border-bottom: 1px solid var(--border-color);
            line-height: 1.4;
            transition: all 0.2s ease;
        }

        .log-entry:hover {
            background: var(--secondary-bg);
        }

        .log-entry:last-child {
            border-bottom: none;
        }

        .log-entry.success {
            border-left-color: var(--success-color);
            background: rgba(63, 185, 80, 0.05);
        }

        .log-entry.error {
            border-left-color: var(--danger-color);
            background: rgba(248, 81, 73, 0.05);
        }

        .log-entry.warning {
            border-left-color: var(--warning-color);
            background: rgba(247, 133, 0, 0.05);
        }

        /* Backwards compatibility for activity log */
        .activity-log {
            max-height: 400px;
            overflow-y: auto;
            border-radius: 8px;
            border: 1px solid var(--border-color);
            background: var(--primary-bg);
        }

        .activity-entry {
            font-family: 'SF Mono', Monaco, 'Cascadia Code', 'Roboto Mono', Consolas, 'Courier New', monospace;
            font-size: 0.8125rem;
            padding: 0.75rem 1rem;
            border-left: 3px solid var(--border-color);
            border-bottom: 1px solid var(--border-color);
            line-height: 1.4;
            transition: all 0.2s ease;
            display: grid;
            grid-template-columns: auto 1fr auto;
            align-items: center;
            gap: 1rem;
        }

        .activity-entry:hover {
            background: var(--secondary-bg);
        }

        .activity-entry:last-child {
            border-bottom: none;
        }

        .activity-entry.success {
            border-left-color: var(--success-color);
            background: rgba(63, 185, 80, 0.05);
        }

        .activity-entry.error {
            border-left-color: var(--danger-color);
            background: rgba(248, 81, 73, 0.05);
        }

        .activity-entry.warning {
            border-left-color: var(--warning-color);
            background: rgba(247, 133, 0, 0.05);
        }

        .activity-entry.info {
            border-left-color: var(--accent-color);
            background: rgba(88, 166, 255, 0.05);
        }

        .activity-time {
            font-family: 'JetBrains Mono', 'SF Mono', Monaco, 'Cascadia Code', 'Roboto Mono', Consolas, 'Courier New', monospace;
            color: var(--text-secondary);
            flex-shrink: 0;
            font-weight: 500;
            background: var(--secondary-bg);
            padding: 0.5rem 0.75rem;
            border-radius: 4px;
            font-size: 0.8rem;
            min-width: 5.5rem;
            text-align: center;
            border: 1px solid var(--border-color);
        }

        .activity-message {
            color: var(--text-primary);
            font-weight: 500;
            line-height: 1.4;
        }

        .activity-category {
            font-family: 'JetBrains Mono', 'SF Mono', Monaco, 'Cascadia Code', 'Roboto Mono', Consolas, 'Courier New', monospace;
            font-size: 0.7rem;
            font-weight: 600;
            text-transform: uppercase;
            padding: 0.375rem 0.75rem;
            border-radius: 4px;
            letter-spacing: 0.025em;
            flex-shrink: 0;
            border: 1px solid transparent;
        }

        .activity-category.system {
            background: var(--secondary-bg);
            color: var(--text-secondary);
            border-color: var(--border-color);
        }

        .activity-category.api {
            background: rgba(37, 99, 235, 0.1);
            color: var(--accent-color);
            border-color: rgba(37, 99, 235, 0.2);
        }

        .activity-category.api_summary {
            background: rgba(5, 150, 105, 0.1);
            color: var(--success-color);
            border-color: rgba(5, 150, 105, 0.2);
        }

        .activity-category.stock_alert {
            background: rgba(217, 119, 6, 0.1);
            color: var(--warning-color);
            border-color: rgba(217, 119, 6, 0.2);
        }

        .activity-category.stock_status {
            background: rgba(5, 150, 105, 0.1);
            color: var(--success-color);
            border-color: rgba(5, 150, 105, 0.2);
        }

        .activity-category.user_action {
            background: rgba(139, 92, 246, 0.1);
            color: #8b5cf6;
            border-color: rgba(139, 92, 246, 0.2);
        }

        .activity-category.config {
            background: rgba(236, 72, 153, 0.1);
            color: #ec4899;
            border-color: rgba(236, 72, 153, 0.2);
        }

        .activity-entry.success .activity-message {
            color: var(--success-color);
            font-weight: 600;
        }

        .activity-entry.error .activity-message {
            color: var(--danger-color);
            font-weight: 600;
        }

        .activity-entry.warning .activity-message {
            color: var(--warning-color);
            font-weight: 600;
        }

        /* Special styling for stock status entries */
        .activity-entry.success[data-category="stock_status"] .activity-message::before {
            content: 'ðŸŸ¢ ';
            font-size: 0.8em;
        }

        .activity-entry.info[data-category="stock_status"] .activity-message::before {
            content: 'ðŸ”´ ';
            font-size: 0.8em;
        }

        .activity-entry.info[data-category="stock_status"] .activity-message {
            color: var(--text-muted);
        }

        @media (max-width: 768px) {
            .container {
                padding: 0.5rem;
            }

            .header h1 {
                font-size: 1.5rem;
            }

            .sticky-timer {
                top: 0.5rem;
                right: 0.5rem;
                padding: 0.75rem 1rem;
                font-size: 0.75rem;
            }

            .product-row {
                grid-template-columns: 60px 1fr 80px;
                gap: 0.75rem;
                padding: 0.75rem 1rem;
            }

            .product-tcin-cell,
            .product-action-cell {
                display: none;
            }

            .product-status-cell {
                text-align: right;
            }

            .status-badge {
                font-size: 0.625rem;
                padding: 0.25rem 0.5rem;
            }

            .activity-wrapper {
                min-height: 150px;
            }

            .activity-entry {
                grid-template-columns: 1fr;
                gap: 0.5rem;
                text-align: left;
            }

            .activity-time {
                min-width: auto;
                text-align: left;
                order: 1;
            }

            .activity-message {
                order: 2;
            }

            .activity-category {
                order: 3;
                justify-self: start;
            }
        }

        /* Loading states */
        .loading {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 2px solid var(--border-color);
            border-radius: 50%;
            border-top-color: var(--accent-color);
            animation: spin 1s ease-in-out infinite;
        }

        /* Keyframe animations */
        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        @keyframes pulse {
            0%, 100% {
                opacity: 1;
            }
            50% {
                opacity: 0.5;
            }
        }

        /* Custom scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--secondary-bg);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--border-color);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--text-muted);
        }

        /* Tab Styles */
        .tab-navigation {
            display: flex;
            gap: 0.25rem;
            background: var(--secondary-bg);
            padding: 0.25rem;
            border-radius: 8px;
            border: 1px solid var(--border-color);
        }

        .tab-button {
            padding: 0.75rem 1.5rem;
            background: transparent;
            border: none;
            border-radius: 6px;
            color: var(--text-muted);
            font-size: 0.875rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            white-space: nowrap;
        }

        .tab-button:hover {
            background: var(--card-bg);
            color: var(--text-primary);
        }

        .tab-button.active {
            background: var(--card-bg);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .tab-content-container {
            min-height: 200px;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .tab-content-wrapper {
            padding: 0;
        }

        .btn-disabled {
            background: var(--secondary-bg) !important;
            color: var(--text-muted) !important;
            border-color: var(--border-color) !important;
            cursor: not-allowed !important;
        }

        /* ====================================
           NEW MODERN UI COMPONENTS - V2
           ==================================== */

        /* Hero Metrics Section */
        .hero-metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: var(--space-8);
            margin-bottom: var(--space-8);
        }

        .metric-card {
            background: var(--bg-elevated);
            border: 1px solid var(--border-subtle);
            border-radius: 16px;
            padding: var(--space-8);
            position: relative;
            overflow: hidden;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .metric-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: var(--gradient-primary);
        }

        .metric-card.success::before {
            background: var(--gradient-success);
        }

        .metric-card.premium::before {
            background: var(--gradient-premium);
        }

        .metric-card.info::before {
            background: linear-gradient(135deg, var(--info) 0%, var(--accent-tertiary) 100%);
        }

        .metric-card:hover {
            transform: translateY(-4px);
            box-shadow: var(--shadow-lg);
            border-color: var(--border-accent);
        }

        .metric-label {
            font-size: var(--text-sm);
            color: var(--text-tertiary);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            font-weight: 600;
            margin-bottom: 12px;
        }

        .metric-value {
            font-size: var(--text-display);
            font-weight: var(--text-display-weight);
            color: var(--text-primary);
            line-height: 1;
            margin-bottom: 8px;
            font-family: var(--font-display);
        }

        .metric-trend {
            font-size: var(--text-xs);
            color: var(--text-muted);
        }

        .trend-up {
            color: var(--success);
        }

        .trend-down {
            color: var(--danger);
        }

        /* Dashboard Layout */
        .dashboard-layout {
            display: grid;
            grid-template-columns: 1fr 400px;
            gap: var(--space-8);
            align-items: start;
        }

        /* Product Grid */
        .product-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: var(--space-6);
        }

        .product-card {
            background: var(--bg-card);
            border: 1px solid var(--border-subtle);
            border-radius: 12px;
            padding: var(--space-5);
            transition: all 0.2s ease;
            position: relative;
            overflow: hidden;
        }

        .product-card::before {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            width: 4px;
            background: var(--border-subtle);
            transition: background 0.2s ease;
        }

        .product-card[data-status="in-stock"]::before {
            background: var(--success);
            box-shadow: 0 0 12px var(--success);
        }

        .product-card[data-status="out-of-stock"]::before {
            background: var(--danger);
        }

        .product-card[data-status="attempting"]::before {
            background: var(--warning);
            box-shadow: 0 0 12px var(--warning);
        }

        .product-card:hover {
            border-color: var(--border-accent);
            transform: translateY(-2px);
            box-shadow: var(--shadow-md);
        }

        .product-card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--space-4);
        }

        .product-tcin {
            font-family: var(--font-mono);
            font-size: var(--text-xs);
            color: var(--text-muted);
            background: var(--bg-secondary);
            padding: 4px 8px;
            border-radius: 4px;
        }

        .product-card-body {
            margin-bottom: var(--space-4);
        }

        .product-name {
            font-size: var(--text-body);
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 12px;
            line-height: var(--leading-tight);
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }

        .product-image {
            width: 100%;
            aspect-ratio: 1;
            background: var(--bg-secondary);
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .product-image img {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }

        .product-badges {
            display: flex;
            gap: var(--space-2);
            flex-wrap: wrap;
            margin-bottom: var(--space-4);
        }

        .product-badge {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 6px 12px;
            border-radius: 6px;
            font-size: var(--text-xs);
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .product-badge.in-stock {
            background: var(--success-bg);
            color: var(--success);
            border: 1px solid var(--success-border);
        }

        .product-badge.out-of-stock {
            background: var(--danger-bg);
            color: var(--danger);
            border: 1px solid var(--danger-border);
        }

        .product-badge.preorder {
            background: var(--info-bg);
            color: var(--info);
            border: 1px solid var(--info-border);
        }

        .product-badge.attempting {
            background: var(--warning-bg);
            color: var(--warning);
            border: 1px solid var(--warning-border);
            animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
        }

        .product-badge.purchased {
            background: rgba(139, 92, 246, 0.1);
            color: var(--accent-secondary);
            border: 1px solid rgba(139, 92, 246, 0.3);
        }

        .product-card-footer {
            display: flex;
            gap: var(--space-2);
            justify-content: flex-end;
        }

        /* Activity Feed */
        .activity-feed {
            background: var(--bg-secondary);
            border-radius: 12px;
            padding: var(--space-6);
            max-height: 600px;
            overflow-y: auto;
            position: sticky;
            top: calc(var(--space-8) + 80px);
        }

        .activity-feed-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--space-5);
            padding-bottom: var(--space-4);
            border-bottom: 1px solid var(--border-subtle);
        }

        .activity-feed-title {
            font-size: var(--text-h2);
            font-weight: 600;
            color: var(--text-primary);
        }

        .activity-feed-entries {
            display: flex;
            flex-direction: column;
            gap: var(--space-2);
        }

        .activity-entry {
            display: flex;
            gap: 12px;
            padding: 12px;
            border-radius: 8px;
            transition: background 0.2s ease;
        }

        .activity-entry:hover {
            background: var(--bg-elevated);
        }

        .activity-entry.new {
            animation: slideInRight 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .activity-icon {
            width: 32px;
            height: 32px;
            min-width: 32px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
            background: var(--bg-elevated);
        }

        .activity-icon.success {
            background: var(--success-bg);
            color: var(--success);
        }

        .activity-icon.info {
            background: var(--info-bg);
            color: var(--info);
        }

        .activity-icon.error {
            background: var(--danger-bg);
            color: var(--danger);
        }

        .activity-icon.warning {
            background: var(--warning-bg);
            color: var(--warning);
        }

        .activity-content {
            flex: 1;
            min-width: 0;
        }

        .activity-message {
            font-size: var(--text-body-sm);
            color: var(--text-secondary);
            margin-bottom: 4px;
            line-height: var(--leading-normal);
        }

        .activity-time {
            font-size: var(--text-xs);
            color: var(--text-muted);
            font-family: var(--font-mono);
        }

        /* Buttons */
        .btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: var(--space-2);
            padding: 10px 20px;
            border-radius: 8px;
            font-size: var(--text-body-sm);
            font-weight: 600;
            border: none;
            cursor: pointer;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            white-space: nowrap;
        }

        .btn-primary {
            background: var(--gradient-primary);
            color: white;
            box-shadow: 0 2px 8px rgba(59, 130, 246, 0.3);
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .btn-secondary {
            background: var(--bg-elevated);
            color: var(--text-primary);
            border: 1px solid var(--border-default);
        }

        .btn-secondary:hover {
            background: var(--bg-card-hover);
            border-color: var(--border-accent);
        }

        .btn-danger {
            background: var(--danger);
            color: white;
        }

        .btn-danger:hover {
            background: #dc2626;
            transform: translateY(-1px);
        }

        .btn-icon {
            width: 36px;
            height: 36px;
            padding: 0;
            border-radius: 8px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-subtle);
            color: var(--text-tertiary);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .btn-icon:hover {
            background: var(--bg-elevated);
            color: var(--text-primary);
            border-color: var(--border-default);
        }

        .btn-icon.danger:hover {
            background: var(--danger-bg);
            border-color: var(--danger-border);
            color: var(--danger);
        }

        .btn-icon svg {
            width: 18px;
            height: 18px;
        }

        /* Icon Sizes */
        .icon {
            display: inline-block;
            vertical-align: middle;
        }

        .icon-sm { width: 16px; height: 16px; }
        .icon-md { width: 20px; height: 20px; }
        .icon-lg { width: 24px; height: 24px; }
        .icon-xl { width: 32px; height: 32px; }

        /* Form Elements */
        .form-group {
            margin-bottom: var(--space-5);
        }

        .form-label {
            display: block;
            font-size: var(--text-sm);
            font-weight: 600;
            color: var(--text-secondary);
            margin-bottom: var(--space-2);
        }

        .form-input {
            width: 100%;
            padding: 12px 16px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-subtle);
            border-radius: 8px;
            color: var(--text-primary);
            font-size: var(--text-body);
            transition: all 0.2s ease;
            font-family: var(--font-primary);
        }

        .form-input:focus {
            outline: none;
            border-color: var(--accent-primary);
            box-shadow: 0 0 0 3px rgba(96, 165, 250, 0.1);
        }

        .form-input::placeholder {
            color: var(--text-muted);
        }

        .form-input[type="text"].tcin-input {
            font-family: var(--font-mono);
            letter-spacing: 0.05em;
        }

        /* Animations */
        @keyframes pulse {
            0%, 100% {
                opacity: 1;
                transform: scale(1);
            }
            50% {
                opacity: 0.8;
                transform: scale(1.05);
            }
        }

        @keyframes slideInRight {
            from {
                opacity: 0;
                transform: translateX(20px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        .updating {
            animation: pulse 0.5s ease-in-out;
        }

        /* Responsive Breakpoints */
        @media (min-width: 1600px) {
            .container { max-width: 1600px; }
            .product-grid { grid-template-columns: repeat(4, 1fr); }
        }

        @media (max-width: 1199px) {
            .dashboard-layout {
                grid-template-columns: 1fr;
            }

            .product-grid {
                grid-template-columns: repeat(2, 1fr);
            }

            .activity-feed {
                max-height: 400px;
                position: relative;
                top: 0;
            }
        }

        @media (max-width: 767px) {
            .container {
                padding: var(--space-4);
            }

            .metric-card {
                padding: var(--space-5);
            }

            .metric-value {
                font-size: 2.5rem;
            }

            .product-grid {
                grid-template-columns: 1fr;
            }

            .hero-metrics {
                grid-template-columns: 1fr;
                gap: var(--space-4);
            }
        }

    </style>
</head>
<body>
    <!-- Sticky Timer -->
    <div class="sticky-timer">
        <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
            <path d="M17.65 6.35C16.2 4.9 14.21 4 12 4c-4.42 0-7.99 3.58-7.99 8s3.57 8 7.99 8c3.73 0 6.84-2.55 7.73-6h-2.08c-.82 2.33-3.04 4-5.65 4-3.31 0-6-2.69-6-6s2.69-6 6-6c1.66 0 3.14.69 4.22 1.78L13 11h7V4l-2.35 2.35z"/>
        </svg>
        <span>Refresh in</span>
        <span class="countdown" id="countdown-value">25</span>
    </div>

    <div class="header">
        <div class="header-content">
            <h1>Target.com Monitoring System</h1>
            <div class="header-stats">
                <div class="header-stat">
                    <div class="header-stat-label">Last Update</div>
                    <div class="header-stat-value">{{ timestamp.strftime('%H:%M:%S') }}</div>
                </div>
                <div class="header-stat">
                    <div class="header-stat-label">Products</div>
                    <div class="header-stat-value">{{ config.products | length }}</div>
                </div>
                <div class="header-stat">
                    <div class="header-stat-label">Status</div>
                    <div class="header-stat-value" style="color: {{ 'var(--success-color)' if status.monitoring else 'var(--danger-color)' }}">
                        {{ 'LIVE' if status.monitoring else 'OFF' }}
                    </div>
                </div>
                <div class="header-stat">
                    <div class="header-stat-label">Next Refresh</div>
                    <div class="header-stat-value" style="color: var(--accent-color); display: flex; align-items: center; gap: 0.5rem;">
                        <svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M17.65 6.35C16.2 4.9 14.21 4 12 4c-4.42 0-7.99 3.58-7.99 8s3.57 8 7.99 8c3.73 0 6.84-2.55 7.73-6h-2.08c-.82 2.33-3.04 4-5.65 4-3.31 0-6-2.69-6-6s2.69-6 6-6c1.66 0 3.14.69 4.22 1.78L13 11h7V4l-2.35 2.35z"/>
                        </svg>
                        <span id="countdown-value-header">25</span>s
                    </div>
                </div>
            </div>
        </div>
    </div>


    <div class="container">

        <!-- Hero Metrics Section -->
        <div class="hero-metrics">
            <!-- In Stock Count Card -->
            <div class="metric-card success" id="metric-in-stock">
                <div class="metric-label">In Stock Products</div>
                <div class="metric-value">{{ status.in_stock_count }}</div>
                <div class="metric-trend">
                    <span class="trend-up">Available now</span>
                </div>
            </div>

            <!-- Total Products Card -->
            <div class="metric-card info" id="metric-total-products">
                <div class="metric-label">Total Products</div>
                <div class="metric-value">{{ config.products | length }}</div>
                <div class="metric-trend">
                    Monitored SKUs
                </div>
            </div>
        </div>

        <!-- Monitored Products -->
        <div class="section">
            <div class="section-header">
                <div class="section-title">ðŸ“¦ Monitored Products</div>
            </div>
            <div class="section-content">
                {% if config.products %}
                <div class="table-container">
                    <table>
                        <thead>
                            <tr>
                                <th>TCIN</th>
                                <th>Product Name</th>
                                <th>Preorder</th>
                                <th>Stock Status</th>
                                <th>Purchase Status</th>
                                <th>Actions</th>
                            </tr>
                        </thead>
                        <tbody>
                            {% for product in config.products %}
                            <tr data-tcin="{{ product.tcin }}">
                                <td>
                                    <code style="background: var(--secondary-bg); padding: 0.25rem 0.5rem; border-radius: 4px; font-size: 0.875rem;">
                                        {{ product.tcin }}
                                    </code>
                                </td>
                                <td>
                                    <div style="max-width: 350px; font-weight: 500;" class="product-name">
                                        {{ product.display_name or product.name or 'Loading...' }}
                                    </div>
                                </td>
                                <td>
                                    <span class="badge preorder preorder-badge" data-tcin="{{ product.tcin }}"
                                          style="display: {{ 'inline-flex' if product.has_data and product.is_preorder else 'none' }}"
                                          {% if product.street_date %}title="Pre-order - Releases {{ product.street_date }}"{% endif %}>
                                        PREORDER
                                    </span>
                                </td>
                                <td>
                                    {% if product.has_data %}
                                        {% if product.stock_status == 'WAITING_FOR_REFRESH' %}
                                            <span class="badge unknown" data-tcin="{{ product.tcin }}">
                                                <span class="loading"></span> WAITING FOR REFRESH
                                            </span>
                                        {% else %}
                                            <span class="badge {{ 'in-stock' if product.available else 'out-of-stock' }}" data-tcin="{{ product.tcin }}">
                                                {{ 'IN STOCK' if product.available else 'OUT OF STOCK' }}
                                            </span>
                                        {% endif %}
                                    {% else %}
                                        <span class="badge unknown" data-tcin="{{ product.tcin }}">
                                            <span class="loading"></span> LOADING...
                                        </span>
                                    {% endif %}
                                </td>
                                <td>
                                    {% if product.purchase_status == 'ready' %}
                                        <span class="badge ready" data-tcin="{{ product.tcin }}" id="purchase-status-{{ product.tcin }}">
                                            âœ… READY
                                        </span>
                                    {% elif product.purchase_status == 'attempting' %}
                                        <span class="badge attempting" data-tcin="{{ product.tcin }}" id="purchase-status-{{ product.tcin }}">
                                            â³ ATTEMPTING
                                        </span>
                                    {% elif product.purchase_status == 'purchased' %}
                                        <span class="badge purchased" data-tcin="{{ product.tcin }}" id="purchase-status-{{ product.tcin }}"
                                              {% if product.order_number %}title="Order: {{ product.order_number }}"{% endif %}>
                                            ðŸŽ‰ PURCHASED
                                        </span>
                                    {% elif product.purchase_status == 'failed' %}
                                        <span class="badge failed" data-tcin="{{ product.tcin }}" id="purchase-status-{{ product.tcin }}"
                                              {% if product.purchase_attempt_count %}title="Failed after {{ product.purchase_attempt_count }} attempts"{% endif %}>
                                            âŒ FAILED
                                        </span>
                                    {% else %}
                                        <span class="badge ready" data-tcin="{{ product.tcin }}" id="purchase-status-{{ product.tcin }}">
                                            âœ… READY
                                        </span>
                                    {% endif %}
                                </td>
                                <td>
                                    <a href="{{ product.url }}" target="_blank" class="btn btn-outline">
                                        View Product
                                    </a>
                                </td>
                            </tr>
                            {% endfor %}
                        </tbody>
                    </table>
                </div>
                {% else %}
                <div style="text-align: center; padding: 2rem; color: var(--text-muted);">
                    No products configured for monitoring
                </div>
                {% endif %}
            </div>
        </div>

        <!-- Live Activity Log -->
        <div class="section">
            <div class="section-header">
                <div class="section-title">ðŸ“‹ Live Activity Log</div>
                <button id="clear-logs-btn" class="clear-logs-btn" onclick="clearActivityLogs()">
                    ðŸ—‘ï¸ Clear Logs
                </button>
            </div>
            <div class="section-content">
                <div class="log-container" style="max-height: 300px;">
                    {% if activity_log %}
                        {% for entry in activity_log[:25] %}
                        <div class="log-entry {{ entry.level }}">
                            <span style="opacity: 0.7;">[{{ entry.time_str }}]</span>
                            ðŸ“‹ {{ entry.message }}
                        </div>
                        {% endfor %}
                    {% else %}
                        <div class="log-entry">
                            <span style="opacity: 0.7;">[{{ timestamp.strftime('%H:%M:%S') }}]</span>
                            ðŸ“‹ Dashboard started - monitoring {{ config.products | length }} products
                        </div>
                    {% endif %}
                </div>
            </div>
        </div>

        <!-- Product Configuration -->
        <div class="section">
            <div class="section-header">
                <div class="section-title">âš™ï¸ Product Configuration</div>
            </div>
            <div class="section-content">
                <!-- Tab Navigation -->
                <div class="tab-navigation" style="margin-bottom: 1.5rem;">
                    <button class="tab-button active" onclick="switchTab('active')" id="active-tab">
                        ðŸ“Š Active Products ({{ config.products|length }})
                    </button>
                    <button class="tab-button" onclick="switchTab('catalog')" id="catalog-tab">
                        ðŸ“š Product Catalog ({{ catalog.catalog|length }})
                    </button>
                </div>

                <!-- Tab Content Container -->
                <div class="tab-content-container">
                    <!-- Active Products Tab -->
                    <div class="tab-content active" id="active-content">
                        <div class="tab-content-wrapper">
                <!-- Add Product Form -->
                <form onsubmit="handleAddProduct(event)" style="margin-bottom: 2rem;">
                    <div style="display: flex; gap: 1rem; align-items: center; max-width: 500px;">
                        <input
                            type="text"
                            name="tcin"
                            placeholder="Enter TCIN (8-10 digits)..."
                            pattern="[0-9]{8,10}"
                            maxlength="10"
                            required
                            style="
                                flex: 1;
                                padding: 0.75rem 1rem;
                                background: var(--secondary-bg);
                                border: 1px solid var(--border-color);
                                border-radius: 6px;
                                color: var(--text-primary);
                                font-size: 0.875rem;
                                font-family: 'JetBrains Mono', monospace;
                            "
                        />
                        <button
                            type="submit"
                            class="btn btn-primary"
                            style="white-space: nowrap;"
                        >
                            âž• Add Product
                        </button>
                    </div>
                    <div style="margin-top: 0.5rem; font-size: 0.75rem; color: var(--text-muted);">
                        Product name will be automatically fetched from Target's API
                    </div>
                </form>

                <!-- Current Products Management -->
                {% if config.products %}
                <div style="font-size: 0.875rem; color: var(--text-secondary); margin-bottom: 1rem; font-weight: 500;">
                    Manage Existing Products:
                </div>
                <div class="product-config-container" style="max-height: 300px; overflow-y: auto; border: 1px solid var(--border-color); border-radius: 8px;">
                    {% for product in config.products %}
                    <div data-tcin="{{ product.tcin }}" style="
                        display: flex;
                        align-items: center;
                        padding: 1rem;
                        border-bottom: 1px solid var(--border-color);
                        background: var(--secondary-bg);
                    " {% if loop.last %}style="border-bottom: none;"{% endif %}>
                        <!-- Product Info -->
                        <div style="flex: 1; min-width: 0;">
                            <div class="product-config-name" style="font-weight: 500; color: var(--text-primary); margin-bottom: 0.25rem;">
                                {{ product.display_name or product.name or 'Unknown Product' }}
                            </div>
                            <div style="font-family: 'JetBrains Mono', monospace; font-size: 0.75rem; color: var(--text-muted);">
                                TCIN: {{ product.tcin }}
                            </div>
                        </div>

                        <!-- Controls -->
                        <div style="display: flex; align-items: center; gap: 1rem;">
                            <!-- Delete Button -->
                            <button
                                onclick="handleRemoveProduct('{{ product.tcin }}')"
                                style="
                                    background: transparent;
                                    border: 1px solid var(--danger-color);
                                    color: var(--danger-color);
                                    padding: 0.375rem 0.75rem;
                                    border-radius: 4px;
                                    font-size: 0.75rem;
                                    cursor: pointer;
                                    transition: all 0.2s ease;
                                "
                                onmouseover="this.style.background='var(--danger-color)'; this.style.color='white';"
                                onmouseout="this.style.background='transparent'; this.style.color='var(--danger-color)';"
                            >
                                ðŸ—‘ï¸ Remove
                            </button>
                        </div>
                    </div>
                    {% endfor %}
                </div>
                        {% else %}
                        <div style="text-align: center; padding: 2rem; color: var(--text-muted); font-style: italic;">
                            No products configured. Add your first product using the form above.
                        </div>
                        {% endif %}
                        </div>
                    </div>

                    <!-- Product Catalog Tab -->
                    <div class="tab-content" id="catalog-content">
                        <div class="tab-content-wrapper">
                            <!-- Add to Catalog Form -->
                            <form onsubmit="handleAddToCatalog(event)" style="margin-bottom: 2rem;">
                                <div style="display: flex; gap: 1rem; align-items: center; max-width: 500px;">
                                    <input
                                        type="text"
                                        name="tcin"
                                        placeholder="Enter TCIN (8-10 digits)..."
                                        pattern="[0-9]{8,10}"
                                        maxlength="10"
                                        required
                                        style="
                                            flex: 1;
                                            padding: 0.75rem 1rem;
                                            background: var(--secondary-bg);
                                            border: 1px solid var(--border-color);
                                            border-radius: 6px;
                                            color: var(--text-primary);
                                            font-size: 0.875rem;
                                            font-family: 'JetBrains Mono', monospace;
                                        "
                                    />
                                    <button
                                        type="submit"
                                        class="btn btn-secondary"
                                        style="
                                            padding: 0.75rem 1.5rem;
                                            white-space: nowrap;
                                        "
                                    >
                                        ðŸ“š Save to Catalog
                                    </button>
                                </div>
                            </form>

                            <!-- Current Catalog Products -->
                            {% if catalog.catalog %}
                            <div style="font-size: 0.875rem; color: var(--text-secondary); margin-bottom: 1rem; font-weight: 500;">
                                Catalog Products:
                            </div>
                            <div class="catalog-config-container" style="max-height: 300px; overflow-y: auto; border: 1px solid var(--border-color); border-radius: 8px;">
                                {% for product in catalog.catalog %}
                                <div data-catalog-tcin="{{ product.tcin }}" style="
                                    display: flex;
                                    align-items: center;
                                    padding: 1rem;
                                    border-bottom: 1px solid var(--border-color);
                                    background: var(--secondary-bg);
                                " {% if loop.last %}style="border-bottom: none;"{% endif %}>
                                    <!-- Product Info -->
                                    <div style="flex: 1; min-width: 0;">
                                        <div class="catalog-product-name" style="font-weight: 500; color: var(--text-primary); margin-bottom: 0.25rem;">
                                            {{ product.name }}
                                        </div>
                                        <div style="font-family: 'JetBrains Mono', monospace; font-size: 0.75rem; color: var(--text-muted);">
                                            TCIN: {{ product.tcin }} â€¢ Added: {{ product.date_added[:10] }}
                                        </div>
                                    </div>

                                    <!-- Smart Action Buttons -->
                                    <div style="display: flex; align-items: center; gap: 0.75rem;">
                                        <!-- COHESIVE SYSTEM: Use the is_actively_monitored property from backend -->
                                        {% set is_active = product.is_actively_monitored %}

                                        <!-- Add to Monitor Button -->
                                        <button
                                            onclick="activateFromCatalog('{{ product.tcin }}')"
                                            class="btn {% if is_active %}btn-disabled{% else %}btn-primary{% endif %}"
                                            {% if is_active %}disabled{% endif %}
                                            style="
                                                padding: 0.375rem 0.75rem;
                                                font-size: 0.75rem;
                                                white-space: nowrap;
                                                {% if is_active %}opacity: 0.5; cursor: not-allowed;{% endif %}
                                            "
                                        >
                                            {% if is_active %}âœ… Already Active{% else %}ðŸš€ Add to Monitor{% endif %}
                                        </button>

                                        <!-- Remove from Catalog Button -->
                                        <button
                                            onclick="removeFromCatalog('{{ product.tcin }}')"
                                            style="
                                                background: transparent;
                                                border: 1px solid var(--danger-color);
                                                color: var(--danger-color);
                                                padding: 0.375rem 0.75rem;
                                                border-radius: 4px;
                                                font-size: 0.75rem;
                                                cursor: pointer;
                                                transition: all 0.2s ease;
                                                white-space: nowrap;
                                            "
                                            onmouseover="this.style.background='var(--danger-color)'; this.style.color='white';"
                                            onmouseout="this.style.background='transparent'; this.style.color='var(--danger-color)';"
                                        >
                                            ðŸ—‘ï¸ Remove
                                        </button>
                                    </div>
                                </div>
                                {% endfor %}
                            </div>
                            {% else %}
                            <div style="text-align: center; padding: 2rem; color: var(--text-muted); font-style: italic;">
                                No products in catalog. Save your first product using the form above.
                            </div>
                            {% endif %}
                        </div>
                    </div>
                </div>
            </div>
        </div>

    </div>

    <script>
        // ===============================================
        // TAB MANAGEMENT AND CATALOG FUNCTIONS
        // ===============================================

        function switchTab(tabName) {
            // Remove active class from all tabs and content
            document.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));

            // Add active class to selected tab and content
            document.getElementById(`${tabName}-tab`).classList.add('active');
            document.getElementById(`${tabName}-content`).classList.add('active');
        }

        async function handleAddToCatalog(event) {
            event.preventDefault();
            const form = event.target;
            const formData = new FormData(form);
            const tcin = formData.get('tcin');

            try {
                const response = await fetch('/catalog/add', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ tcin: tcin })
                });

                const result = await response.json();

                if (result.success) {
                    // Clear form
                    form.reset();

                    // Add to catalog UI immediately
                    addProductToCatalogSection(result.product);

                    // Update tab counter
                    updateTabCounters();

                    // Show success message
                    showSuccessToast('Product saved to catalog: ' + result.product.name);
                } else {
                    showErrorToast('Error: ' + result.error);
                }
            } catch (error) {
                console.error('Error adding to catalog:', error);
                showErrorToast('Error adding to catalog: ' + error.message);
            }
        }

        async function removeFromCatalog(tcin) {
            try {
                const response = await fetch(`/catalog/remove/${tcin}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    }
                });

                const result = await response.json();

                if (result.success) {
                    // Remove from catalog UI with animation
                    removeProductFromCatalogSection(tcin);

                    // Update tab counter
                    updateTabCounters();

                    showSuccessToast('Product removed from catalog');
                } else {
                    showErrorToast('Error: ' + result.error);
                }
            } catch (error) {
                console.error('Error removing from catalog:', error);
                showErrorToast('Error removing from catalog: ' + error.message);
            }
        }

        async function activateFromCatalog(tcin) {
            try {
                const response = await fetch(`/catalog/activate/${tcin}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    }
                });

                const result = await response.json();

                if (result.success) {
                    // Add to main table and active config section
                    addProductToMainTable(result.product);
                    addProductToConfigSection(result.product);

                    // Update button state in catalog (disable "Add to Monitor" button)
                    updateCatalogButtonState(tcin, true);

                    // Update tab counters
                    updateTabCounters();

                    // Update metrics immediately
                    updateMetrics();

                    showSuccessToast('Product activated for monitoring: ' + result.product.name);
                } else {
                    showErrorToast('Error: ' + result.error);
                }
            } catch (error) {
                console.error('Error activating from catalog:', error);
                showErrorToast('Error activating from catalog: ' + error.message);
            }
        }

        function addProductToCatalogSection(product) {
            const container = document.querySelector('.catalog-config-container');
            if (!container) {
                // Create container if it doesn't exist (empty state)
                const catalogContent = document.getElementById('catalog-content');
                const existingEmpty = catalogContent.querySelector('div[style*="text-align: center"]');
                if (existingEmpty) {
                    existingEmpty.remove();
                }

                // Add container and header
                const headerDiv = document.createElement('div');
                headerDiv.style.cssText = 'font-size: 0.875rem; color: var(--text-secondary); margin-bottom: 1rem; font-weight: 500;';
                headerDiv.textContent = 'Catalog Products:';

                const newContainer = document.createElement('div');
                newContainer.className = 'catalog-config-container';
                newContainer.style.cssText = 'max-height: 300px; overflow-y: auto; border: 1px solid var(--border-color); border-radius: 8px;';

                catalogContent.querySelector('.tab-content-wrapper').appendChild(headerDiv);
                catalogContent.querySelector('.tab-content-wrapper').appendChild(newContainer);
                container = newContainer;
            }

            const productDiv = document.createElement('div');
            productDiv.setAttribute('data-catalog-tcin', product.tcin);
            productDiv.style.cssText = `
                display: flex;
                align-items: center;
                padding: 1rem;
                border-bottom: 1px solid var(--border-color);
                background: var(--secondary-bg);
                opacity: 0;
                transform: translateY(20px);
                transition: all 0.3s ease;
            `;

            productDiv.innerHTML = `
                <div style="flex: 1; min-width: 0;">
                    <div class="catalog-product-name" style="font-weight: 500; color: var(--text-primary); margin-bottom: 0.25rem;">
                        ${product.name}
                    </div>
                    <div style="font-family: 'JetBrains Mono', monospace; font-size: 0.75rem; color: var(--text-muted);">
                        TCIN: ${product.tcin} â€¢ Added: ${product.date_added.substring(0, 10)}
                    </div>
                </div>
                <div style="display: flex; align-items: center; gap: 0.75rem;">
                    <button
                        onclick="activateFromCatalog('${product.tcin}')"
                        class="btn btn-primary"
                        style="
                            padding: 0.375rem 0.75rem;
                            font-size: 0.75rem;
                            white-space: nowrap;
                        "
                    >
                        ðŸš€ Add to Monitor
                    </button>
                    <button
                        onclick="removeFromCatalog('${product.tcin}')"
                        style="
                            background: transparent;
                            border: 1px solid var(--danger-color);
                            color: var(--danger-color);
                            padding: 0.375rem 0.75rem;
                            border-radius: 4px;
                            font-size: 0.75rem;
                            cursor: pointer;
                            transition: all 0.2s ease;
                            white-space: nowrap;
                        "
                        onmouseover="this.style.background='var(--danger-color)'; this.style.color='white';"
                        onmouseout="this.style.background='transparent'; this.style.color='var(--danger-color)';"
                    >
                        ðŸ—‘ï¸ Remove
                    </button>
                </div>
            `;

            container.appendChild(productDiv);

            // Animate in
            setTimeout(() => {
                productDiv.style.opacity = '1';
                productDiv.style.transform = 'translateY(0)';
            }, 100);
        }

        function removeProductFromCatalogSection(tcin) {
            const div = document.querySelector(`div[data-catalog-tcin="${tcin}"]`);
            if (div) {
                div.style.transition = 'all 0.3s ease';
                div.style.opacity = '0';
                div.style.transform = 'translateX(-20px)';
                setTimeout(() => {
                    div.remove();

                    // Check if this was the last item
                    const container = document.querySelector('.catalog-config-container');
                    if (container && container.children.length === 0) {
                        // Remove container and add empty state
                        container.previousElementSibling?.remove(); // Remove header
                        container.remove();

                        const catalogContent = document.getElementById('catalog-content');
                        const emptyDiv = document.createElement('div');
                        emptyDiv.style.cssText = 'text-align: center; padding: 2rem; color: var(--text-muted); font-style: italic;';
                        emptyDiv.textContent = 'No products in catalog. Save your first product using the form above.';
                        catalogContent.querySelector('.tab-content-wrapper').appendChild(emptyDiv);
                    }
                }, 300);
            }
        }

        function updateCatalogButtonState(tcin, isActive) {
            const catalogItem = document.querySelector(`div[data-catalog-tcin="${tcin}"]`);
            if (catalogItem) {
                const activateButton = catalogItem.querySelector('button[onclick*="activateFromCatalog"]');
                if (activateButton) {
                    if (isActive) {
                        activateButton.disabled = true;
                        activateButton.className = 'btn btn-disabled';
                        activateButton.textContent = 'âœ… Already Active';
                        activateButton.style.opacity = '0.5';
                        activateButton.style.cursor = 'not-allowed';
                    } else {
                        activateButton.disabled = false;
                        activateButton.className = 'btn btn-primary';
                        activateButton.textContent = 'ðŸš€ Add to Monitor';
                        activateButton.style.opacity = '1';
                        activateButton.style.cursor = 'pointer';
                    }
                }
            }
        }

        function updateTabCounters() {
            // Update active products counter
            const activeCount = document.querySelector('table tbody')?.querySelectorAll('tr').length || 0;
            document.getElementById('active-tab').textContent = `ðŸ“Š Active Products (${activeCount})`;

            // Update catalog counter
            const catalogCount = document.querySelector('.catalog-config-container')?.children.length || 0;
            document.getElementById('catalog-tab').textContent = `ðŸ“š Product Catalog (${catalogCount})`;
        }

        function updateMetrics() {
            // Count active products from the main table
            const totalProducts = document.querySelector('table tbody')?.querySelectorAll('tr').length || 0;

            // Count in-stock products
            const inStockCount = document.querySelectorAll('table tbody tr .badge.in-stock').length || 0;

            // Update Total Products metric card
            const totalProductsMetric = document.querySelector('#metric-total-products .metric-value');
            if (totalProductsMetric) {
                totalProductsMetric.textContent = totalProducts;
                console.log(`ðŸ“Š INSTANT METRIC UPDATE: Total products = ${totalProducts}`);
            }

            // Update In Stock metric card
            const inStockMetric = document.querySelector('#metric-in-stock .metric-value');
            if (inStockMetric) {
                inStockMetric.textContent = inStockCount;
                console.log(`ðŸ“Š INSTANT METRIC UPDATE: In stock = ${inStockCount}`);
            }

            // Update header stat for Products
            const headerProductsStat = document.querySelectorAll('.header-stat');
            headerProductsStat.forEach(stat => {
                const label = stat.querySelector('.header-stat-label');
                if (label && label.textContent === 'Products') {
                    const value = stat.querySelector('.header-stat-value');
                    if (value) {
                        value.textContent = totalProducts;
                    }
                }
            });
        }

        // Override the existing handleRemoveProduct to also update catalog button states
        const originalHandleRemoveProduct = window.handleRemoveProduct;
        window.handleRemoveProduct = async function(tcin) {
            const result = await originalHandleRemoveProduct(tcin);

            // Update catalog button state if the product was removed from active
            updateCatalogButtonState(tcin, false);

            // Wait for animation to complete (300ms) before updating counters/metrics
            setTimeout(() => {
                updateTabCounters();
                updateMetrics();
            }, 350);

            return result;
        };

        // ===============================================
        // HEALTH CHECK MONITORING SYSTEM
        // ===============================================

        let healthCheckInterval = null;
        let syncErrorCount = 0;
        let lastHealthCheck = null;
        let validationRetryCount = 0;
        let maxRetries = 3;
        let isAutoCorrectEnabled = true;
        let syncStatus = 'unknown'; // 'healthy', 'error', 'correcting', 'offline'

        function startHealthCheckMonitoring() {
            /**
             * ENHANCED HEALTH CHECK: Proactive sync monitoring with auto-correction
             * - Runs validation every cycle (not every 3rd)
             * - Immediate validation after every atomic API event
             * - Auto-correction of detected sync issues
             * - Real-time sync status indicator
             * - Retry logic for failed validations
             */
            console.log('ðŸ¥ ENHANCED HEALTH CHECK: Starting proactive sync monitoring with auto-correction...');

            // Monitor atomic events and run enhanced health check every cycle
            const originalHandler = handleAtomicApiCycleUpdate;
            handleAtomicApiCycleUpdate = function(eventData) {
                // Call original handler
                originalHandler(eventData);

                // Run enhanced validation immediately after every cycle
                setTimeout(() => runEnhancedHealthCheck(eventData.cycle_id), 500);
            };
        }

        async function runHealthCheck(triggeredByCycleId) {
            /**
             * HEALTH CHECK: Compare frontend state with backend expected state
             * This catches the specific bug scenario automatically
             */
            try {
                console.log(`ðŸ¥ HEALTH CHECK: Running validation (triggered by cycle ${triggeredByCycleId})`);
                lastHealthCheck = new Date();

                const response = await fetch('/api/validate-sync');
                const backendData = await response.json();

                if (!backendData.success) {
                    console.error('ðŸ¥ HEALTH CHECK: Backend validation failed:', backendData.error);
                    return;
                }

                const expectedState = backendData.expected_ui_state;
                const currentUIState = validateCurrentUIState();
                const healthErrors = [];

                // Compare each product's state
                Object.entries(expectedState).forEach(([tcin, expected]) => {
                    const actual = currentUIState[tcin];

                    if (!actual) {
                        healthErrors.push(`${tcin}: Missing from UI`);
                        return;
                    }

                    // Check stock status sync
                    const expectedStockStatus = expected.stock_status;
                    const actualStockText = actual.stock_status;

                    let actualStockStatus = 'UNKNOWN';
                    if (actualStockText.includes('IN STOCK')) actualStockStatus = 'IN_STOCK';
                    else if (actualStockText.includes('OUT OF STOCK')) actualStockStatus = 'OUT_OF_STOCK';

                    if (expectedStockStatus !== actualStockStatus) {
                        healthErrors.push(`${tcin}: Stock status mismatch - Expected ${expectedStockStatus}, Got ${actualStockStatus}`);
                    }

                    // Check purchase status sync
                    const expectedPurchaseStatus = expected.purchase_status;
                    const actualPurchaseText = actual.purchase_status;

                    if (expectedPurchaseStatus === 'ready' && !actualPurchaseText.includes('READY')) {
                        healthErrors.push(`${tcin}: Purchase status mismatch - Expected ready, Got ${actualPurchaseText}`);
                    }
                });

                // Report health check results
                if (healthErrors.length === 0) {
                    console.log(`âœ… HEALTH CHECK PASSED: All UI states match backend (cycle ${triggeredByCycleId})`);
                    syncErrorCount = 0; // Reset error count on success
                    updateHealthStatus('healthy');
                } else {
                    syncErrorCount++;
                    console.error(`ðŸš¨ HEALTH CHECK FAILED: ${healthErrors.length} sync issues detected (cycle ${triggeredByCycleId}):`);
                    healthErrors.forEach(error => console.error(`   - ${error}`));

                    updateHealthStatus('error', healthErrors);

                    // Alert user if multiple consecutive failures
                    if (syncErrorCount >= 2) {
                        showSyncErrorAlert(healthErrors, triggeredByCycleId);
                    }
                }

            } catch (error) {
                console.error('ðŸ¥ HEALTH CHECK: Validation request failed:', error);
                updateHealthStatus('offline');
            }
        }

        function updateHealthStatus(status, errors = []) {
            /**
             * Update health status indicator in UI
             */
            const indicator = document.getElementById('health-status') || createHealthStatusIndicator();
            const timestamp = new Date().toLocaleTimeString();

            switch (status) {
                case 'healthy':
                    indicator.style.color = 'var(--success-color)';
                    indicator.textContent = 'âœ… SYNC OK';
                    indicator.title = `Last check: ${timestamp} - All systems synchronized`;
                    break;
                case 'error':
                    indicator.style.color = 'var(--danger-color)';
                    indicator.textContent = 'âŒ SYNC ERROR';
                    indicator.title = `Last check: ${timestamp} - ${errors.length} sync issues detected`;
                    break;
                case 'offline':
                    indicator.style.color = 'var(--warning-color)';
                    indicator.textContent = 'âš ï¸ HEALTH CHECK OFFLINE';
                    indicator.title = `Last check: ${timestamp} - Health check unavailable`;
                    break;
            }
        }

        function createHealthStatusIndicator() {
            /**
             * Create health status indicator in header
             */
            const headerStats = document.querySelector('.header-stats');
            if (!headerStats) return null;

            const healthStat = document.createElement('div');
            healthStat.className = 'header-stat';
            healthStat.innerHTML = `
                <div class="header-stat-label">Sync Health</div>
                <div class="header-stat-value" id="health-status">ðŸ”„ CHECKING</div>
            `;
            headerStats.appendChild(healthStat);

            return document.getElementById('health-status');
        }

        function showSyncErrorAlert(errors, cycleId) {
            /**
             * Show persistent sync error alert to user
             */
            const alertHtml = `
                <div style="
                    position: fixed;
                    top: 80px;
                    right: 20px;
                    background: var(--danger-color);
                    color: white;
                    padding: 1rem 1.5rem;
                    border-radius: 8px;
                    box-shadow: var(--shadow-xl);
                    z-index: 1000;
                    max-width: 400px;
                    font-size: 0.875rem;
                " id="sync-error-alert">
                    <div style="font-weight: 600; margin-bottom: 0.5rem;">ðŸš¨ Sync Error Detected</div>
                    <div style="margin-bottom: 0.5rem;">The UI is not properly syncing with backend data (Cycle ${cycleId}):</div>
                    <ul style="margin: 0.5rem 0; padding-left: 1rem;">
                        ${errors.map(error => `<li>${error}</li>`).join('')}
                    </ul>
                    <div style="margin-top: 0.5rem; font-size: 0.75rem; opacity: 0.9;">
                        Try refreshing the page. If the issue persists, check console logs.
                    </div>
                    <button onclick="document.getElementById('sync-error-alert').remove()"
                            style="position: absolute; top: 0.5rem; right: 0.5rem; background: none; border: none; color: white; cursor: pointer;">Ã—</button>
                </div>
            `;

            // Remove existing alert
            const existingAlert = document.getElementById('sync-error-alert');
            if (existingAlert) existingAlert.remove();

            // Add new alert
            document.body.insertAdjacentHTML('beforeend', alertHtml);

            // Auto-remove after 30 seconds
            setTimeout(() => {
                const alert = document.getElementById('sync-error-alert');
                if (alert) alert.remove();
            }, 30000);
        }

        // ===============================================
        // TIMER DRIFT MONITORING
        // ===============================================

        let timerDriftHistory = [];
        const MAX_DRIFT_HISTORY = 10;
        let lastValidTimerSync = null;

        function validateTimerMeasurement(oldCountdown, newCountdown, cycleId) {
            /**
             * TIMER MEASUREMENT VALIDATION: Filter out invalid drift measurements
             * This prevents false positives from bad timing or state issues
             */

            // Skip if values are clearly invalid
            if (oldCountdown < 0 || newCountdown < 0) {
                console.log(`â° VALIDATION: Skipping negative timer values (old: ${oldCountdown}, new: ${newCountdown})`);
                return false;
            }

            // Skip if values are unreasonably high (>30s for a 15-25s cycle system)
            if (oldCountdown > 30 || newCountdown > 30) {
                console.log(`â° VALIDATION: Skipping unreasonably high timer values (old: ${oldCountdown}, new: ${newCountdown})`);
                return false;
            }

            // Skip if this is the first sync after page load (no valid baseline)
            if (lastValidTimerSync === null) {
                console.log(`â° VALIDATION: First timer sync after page load - establishing baseline`);
                lastValidTimerSync = { oldCountdown, newCountdown, cycleId, timestamp: Date.now() };
                return false;
            }

            // Skip if frontend timer might be in "refreshing" state
            const countdownElement = document.getElementById('countdown');
            if (countdownElement && countdownElement.classList.contains('refreshing')) {
                console.log(`â° VALIDATION: Skipping measurement - timer in refreshing state`);
                return false;
            }

            // Skip if measurement seems to be during rapid state changes
            const timeSinceLastSync = Date.now() - lastValidTimerSync.timestamp;
            if (timeSinceLastSync < 2000) { // Less than 2 seconds since last sync
                console.log(`â° VALIDATION: Skipping measurement - too soon after last sync (${timeSinceLastSync}ms)`);
                return false;
            }

            // Update last valid sync
            lastValidTimerSync = { oldCountdown, newCountdown, cycleId, timestamp: Date.now() };

            console.log(`â° VALIDATION: Timer measurement valid - proceeding with drift check`);
            return true;
        }

        function logTimerDrift(frontendTime, backendTime, drift, cycleId) {
            /**
             * TIMER DRIFT TRACKING: Log and monitor timer synchronization issues
             */
            // Enhanced drift classification with false positive detection
            let severity = 'low';
            let suspiciousFactor = '';

            if (drift > 15) {
                severity = 'false_positive'; // Extremely high drift is likely measurement error
                suspiciousFactor = 'extreme_drift';
            } else if (drift > 10) {
                severity = 'high';
                suspiciousFactor = 'very_high_drift';
            } else if (drift > 5) {
                severity = 'medium';
            }

            // Check for suspicious patterns that indicate false positives
            if (drift > (frontendTime + backendTime)) {
                severity = 'false_positive';
                suspiciousFactor = 'drift_exceeds_sum';
            }

            const driftEntry = {
                cycleId,
                timestamp: new Date().toISOString(),
                frontendTime,
                backendTime,
                drift,
                severity,
                suspiciousFactor,
                note: severity === 'false_positive' ? 'Likely measurement error' : 'Valid measurement'
            };

            timerDriftHistory.unshift(driftEntry);
            if (timerDriftHistory.length > MAX_DRIFT_HISTORY) {
                timerDriftHistory = timerDriftHistory.slice(0, MAX_DRIFT_HISTORY);
            }

            console.log(`â° TIMER DRIFT LOG:`, driftEntry);

            // Check for persistent drift issues with improved validation
            const recentDrifts = timerDriftHistory.slice(0, 5); // Check last 5 instead of 3
            const validDrifts = recentDrifts.filter(entry => entry.severity !== 'false_positive');

            if (validDrifts.length >= 3) {
                const avgDrift = validDrifts.reduce((sum, entry) => sum + entry.drift, 0) / validDrifts.length;

                // Only alert if consistently high drift (>5s average over multiple cycles)
                if (avgDrift > 5) {
                    console.warn(`âš ï¸ PERSISTENT TIMER DRIFT: Average ${avgDrift.toFixed(1)}s drift over last ${validDrifts.length} valid cycles`);
                    showTimerDriftAlert(avgDrift, validDrifts);
                } else {
                    console.log(`â° DRIFT TRACKING: Minor average drift ${avgDrift.toFixed(1)}s over ${validDrifts.length} cycles - within acceptable range`);
                }
            } else {
                console.log(`â° DRIFT TRACKING: Insufficient valid drift measurements (${validDrifts.length}/3 needed)`);
            }
        }

        function showTimerDriftAlert(avgDrift, recentDrifts) {
            /**
             * Alert user about persistent timer drift issues
             */
            const alertHtml = `
                <div style="
                    position: fixed;
                    top: 130px;
                    right: 20px;
                    background: var(--warning-color);
                    color: white;
                    padding: 1rem 1.5rem;
                    border-radius: 8px;
                    box-shadow: var(--shadow-xl);
                    z-index: 999;
                    max-width: 350px;
                    font-size: 0.875rem;
                " id="timer-drift-alert">
                    <div style="font-weight: 600; margin-bottom: 0.5rem;">â° Timer Drift Warning</div>
                    <div style="margin-bottom: 0.5rem;">
                        Frontend timer is drifting from backend (avg ${avgDrift.toFixed(1)}s over last ${recentDrifts.length} cycles)
                    </div>
                    <div style="font-size: 0.75rem; opacity: 0.9;">
                        This may cause timing inconsistencies. The system auto-corrects on each cycle.
                    </div>
                    <button onclick="document.getElementById('timer-drift-alert').remove()"
                            style="position: absolute; top: 0.5rem; right: 0.5rem; background: none; border: none; color: white; cursor: pointer;">Ã—</button>
                </div>
            `;

            // Remove existing alert
            const existingAlert = document.getElementById('timer-drift-alert');
            if (existingAlert) existingAlert.remove();

            // Add new alert
            document.body.insertAdjacentHTML('beforeend', alertHtml);

            // Auto-remove after 20 seconds
            setTimeout(() => {
                const alert = document.getElementById('timer-drift-alert');
                if (alert) alert.remove();
            }, 20000);
        }

        // Enhanced AJAX Product Management Functions with Loading States
        async function handleAddProduct(event) {
            event.preventDefault();

            const form = event.target;
            const submitButton = form.querySelector('button[type="submit"]');
            const tcin = form.querySelector('input[name="tcin"]').value.trim();

            if (!tcin) return;

            // Show loading state
            const originalButtonText = submitButton.textContent;
            submitButton.disabled = true;
            submitButton.innerHTML = '<div class="loading" style="width: 12px; height: 12px; margin-right: 0.5rem;"></div>Adding...';

            const loadingIndicator = showLoadingIndicator('Adding product...');

            try {
                const response = await fetch('/add-product', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ tcin: tcin })
                });

                const result = await response.json();

                if (result.success) {
                    // Add product to both tables and configuration section immediately
                    addProductToMainTable(result.product);
                    addProductToConfigSection(result.product);

                    // COHESIVE SYSTEM: Add to catalog if not already there and update button state
                    const existingCatalogItem = document.querySelector(`div[data-catalog-tcin="${result.product.tcin}"]`);
                    if (existingCatalogItem) {
                        // Product already in catalog, update button state to "Already Active"
                        updateCatalogButtonState(result.product.tcin, true);
                    } else {
                        // Add to catalog with "Already Active" state
                        const catalogProduct = {
                            tcin: result.product.tcin,
                            name: result.product.name,
                            date_added: new Date().toISOString(),
                            url: result.product.url
                        };
                        addProductToCatalogSection(catalogProduct);
                        // Set to "Already Active" since we just added it to monitoring
                        setTimeout(() => updateCatalogButtonState(result.product.tcin, true), 100);
                    }

                    // Update product count in header and tab counters
                    updateProductCount();
                    updateTabCounters();

                    // Clear form
                    form.reset();

                    // Show success message
                    showSuccessToast('Product added successfully: ' + result.product.name);
                } else {
                    showErrorToast('Error: ' + result.error);
                }
            } catch (error) {
                showErrorToast('Error adding product: ' + error.message);
            } finally {
                // Restore button state
                submitButton.disabled = false;
                submitButton.textContent = originalButtonText;
                loadingIndicator.remove();
            }
        }

        async function handleRemoveProduct(tcin) {
            const loadingIndicator = showLoadingIndicator('Removing product...');

            try {
                const response = await fetch(`/remove-product/${tcin}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    }
                });

                const result = await response.json();

                if (result.success) {
                    // Remove from both tables with animation
                    removeProductFromMainTable(tcin);
                    removeProductFromConfigSection(tcin);

                    // Update product count in header
                    updateProductCount();

                    showSuccessToast('Product removed successfully');
                } else {
                    showErrorToast('Error: ' + result.error);
                }
            } catch (error) {
                showErrorToast('Error removing product: ' + error.message);
            } finally {
                loadingIndicator.remove();
            }
        }


        // DOM Manipulation Functions
        function addProductToMainTable(product) {
            const tbody = document.querySelector('table tbody');
            if (!tbody) return;

            const row = document.createElement('tr');
            row.setAttribute('data-tcin', product.tcin);
            row.style.opacity = '0';
            row.style.transform = 'translateY(20px)';
            row.style.transition = 'all 0.3s ease';

            row.innerHTML = `
                <td>
                    <code style="background: var(--secondary-bg); padding: 0.25rem 0.5rem; border-radius: 4px; font-size: 0.875rem;">
                        ${product.tcin}
                    </code>
                </td>
                <td>
                    <div style="max-width: 350px; font-weight: 500;" class="product-name">
                        ${product.name}
                    </div>
                </td>
                <td>
                    <span class="badge preorder preorder-badge" data-tcin="${product.tcin}" style="display: none">PREORDER</span>
                </td>
                <td>
                    <span class="badge unknown" data-tcin="${product.tcin}">
                        <div class="loading" style="width: 12px; height: 12px; margin-right: 0.5rem;"></div>
                        WAITING FOR REFRESH
                    </span>
                </td>
                <td>
                    <span class="badge ready" data-tcin="${product.tcin}" id="purchase-status-${product.tcin}">âœ… READY</span>
                </td>
                <td>
                    <a href="${product.url}" target="_blank" class="btn btn-outline">View Product</a>
                </td>
            `;
            tbody.appendChild(row);

            // Animate in
            setTimeout(() => {
                row.style.opacity = '1';
                row.style.transform = 'translateY(0)';
            }, 100);
        }

        function addProductToConfigSection(product) {
            const container = document.querySelector('.product-config-container');
            if (!container) return;

            const productDiv = document.createElement('div');
            productDiv.setAttribute('data-tcin', product.tcin);
            productDiv.style.cssText = `
                display: flex;
                align-items: center;
                padding: 1rem;
                border-bottom: 1px solid var(--border-color);
                background: var(--secondary-bg);
            `;

            productDiv.innerHTML = `
                <div style="flex: 1; min-width: 0;">
                    <div class="product-config-name" style="font-weight: 500; color: var(--text-primary); margin-bottom: 0.25rem;">
                        ${product.name}
                    </div>
                    <div style="font-family: 'JetBrains Mono', monospace; font-size: 0.75rem; color: var(--text-muted);">
                        TCIN: ${product.tcin}
                    </div>
                </div>
                <div style="display: flex; align-items: center; gap: 1rem;">
                    <button
                        onclick="handleRemoveProduct('${product.tcin}')"
                        style="background: transparent; border: 1px solid var(--danger-color); color: var(--danger-color); padding: 0.375rem 0.75rem; border-radius: 4px; font-size: 0.75rem; cursor: pointer; transition: all 0.2s ease;"
                    >
                        ðŸ—‘ï¸ Remove
                    </button>
                </div>
            `;

            container.appendChild(productDiv);
        }

        function removeProductFromMainTable(tcin) {
            const row = document.querySelector(`table tr[data-tcin="${tcin}"]`);
            if (row) {
                row.style.transition = 'all 0.3s ease';
                row.style.opacity = '0';
                row.style.transform = 'translateX(-20px)';
                setTimeout(() => {
                    row.remove();
                }, 300);
            }
        }

        function removeProductFromConfigSection(tcin) {
            const div = document.querySelector(`.product-config-container div[data-tcin="${tcin}"]`);
            if (div) {
                div.style.transition = 'all 0.3s ease';
                div.style.opacity = '0';
                div.style.transform = 'translateX(-20px)';
                setTimeout(() => {
                    div.remove();
                }, 300);
            }
        }

        function updateProductCount() {
            const tbody = document.querySelector('table tbody');
            const count = tbody ? tbody.querySelectorAll('tr').length : 0;

            // Update header product count
            const productCountElement = document.querySelector('.header-stat-value');
            if (productCountElement && productCountElement.closest('.header-stat').querySelector('.header-stat-label').textContent === 'Products') {
                productCountElement.textContent = count;
            }

            // Update analytics section
            const analyticsCountElement = document.querySelector('.status-card .status-card-value');
            if (analyticsCountElement) {
                analyticsCountElement.textContent = count;
            }
        }


        // Real-time countdown with server synchronization
        let countdown = 20;
        let timerStartTime = null;  // Server's cycle start time (Unix timestamp)
        let timerDuration = 20;     // Total cycle duration in seconds
        let isRefreshing = false;
        let lastServerSync = 0;
        let countdownInterval = null;
        const countdownElement = document.querySelector('#countdown-value-header');

        function updateCountdown() {
            if (isRefreshing) {
                return;
            }

            // Calculate countdown based on server time (accurate even if page opens mid-cycle)
            if (timerStartTime && timerDuration) {
                const now = Date.now() / 1000;  // Current time in seconds
                countdown = Math.max(0, Math.ceil((timerStartTime + timerDuration) - now));
            } else {
                // Fallback to simple decrement if no server time available
                countdown--;
            }

            if (countdownElement) {
                countdownElement.textContent = countdown;
            }

            if (countdown <= 0) {
                // Show refreshing state but DO NOT reload page
                isRefreshing = true;
                if (countdownElement) {
                    countdownElement.textContent = 'âŸ³';
                    countdownElement.classList.add('refreshing');
                }

                // FIX: Manually fetch current state when timer expires (CRITICAL)
                // Don't passively wait for SSE - actively fetch fresh data
                console.log('ðŸ”„ Timer expired - fetching fresh stock data and activity log...');
                fetch('/api/current-state')
                    .then(response => response.json())
                    .then(data => {
                        console.log('âœ… Timer refresh complete - updating dashboard:', data);

                        // Update stock badges
                        if (data.stock_data) {
                            let updateCount = 0;
                            Object.entries(data.stock_data).forEach(([tcin, stockInfo]) => {
                                updateStockStatus(tcin, stockInfo);
                                updateCount++;
                            });
                            console.log(`âœ… Updated ${updateCount} stock badges from timer refresh`);
                        }

                        // BUGFIX: Update activity log from timer refresh
                        if (data.activity_log && Array.isArray(data.activity_log)) {
                            const logContainer = document.querySelector('.log-container');
                            if (logContainer) {
                                // Clear existing entries and reload to avoid duplicates
                                logContainer.innerHTML = '';
                                console.log(`ðŸ”„ Cleared activity log, loading ${data.activity_log.length} entries...`);

                                // Add entries in reverse order (newest first)
                                data.activity_log.forEach(entry => {
                                    addActivityEntryToDOM(entry);
                                });
                                console.log(`âœ… Updated activity log with ${data.activity_log.length} entries from timer refresh`);
                            } else {
                                console.warn('âš ï¸ Log container not found, cannot update activity log');
                            }
                        } else {
                            console.warn('âš ï¸ No activity_log in timer refresh response');
                        }

                        // Update in-stock count if available
                        if (data.in_stock_count !== undefined) {
                            const inStockElement = document.querySelector('.status-card.warning .status-card-value');
                            if (inStockElement) {
                                inStockElement.textContent = data.in_stock_count;
                                console.log(`âœ… Updated in-stock count: ${data.in_stock_count}`);
                            }
                        }
                    })
                    .catch(error => {
                        console.error('âŒ Timer refresh failed:', error);
                    });

                // Reset countdown for next cycle - fetch timer immediately (no delay)
                // The SSE event should have the correct timer, but fetch as fallback
                setTimeout(() => {
                    // Fetch fresh timer value from server for new cycle
                    fetch('/api/timer-status')
                        .then(response => response.json())
                        .then(data => {
                            if (data.active) {
                                // Store server's timer reference for accurate countdown
                                timerStartTime = data.start_time;
                                timerDuration = data.total;
                                countdown = Math.ceil(data.remaining);
                                console.log(`ðŸ”„ Timer reset: start=${timerStartTime}, duration=${timerDuration}, remaining=${countdown}s`);
                            } else {
                                // Fallback only if server fails
                                timerStartTime = Date.now() / 1000;
                                timerDuration = 20;
                                countdown = 20;
                            }
                            isRefreshing = false;
                            if (countdownElement) {
                                countdownElement.classList.remove('refreshing');
                                countdownElement.textContent = countdown;
                            }
                            // Ensure countdown interval is still running
                            if (!countdownInterval) {
                                countdownInterval = setInterval(updateCountdown, 1000);
                                console.log('ðŸ”„ Restarted countdown interval after reset');
                            }
                        })
                        .catch(error => {
                            console.warn('âš ï¸ Timer reset failed, using fallback:', error);
                            // Fallback on error
                            timerStartTime = Date.now() / 1000;
                            timerDuration = 20;
                            countdown = 20;
                            isRefreshing = false;
                            if (countdownElement) {
                                countdownElement.classList.remove('refreshing');
                                countdownElement.textContent = countdown;
                            }
                            // Ensure countdown interval is still running even on error
                            if (!countdownInterval) {
                                countdownInterval = setInterval(updateCountdown, 1000);
                                console.log('ðŸ”„ Restarted countdown interval after error');
                            }
                        });
                }, 100);  // Reduced from 2000ms - SSE now has accurate timer
            }
            // No need for setTimeout here - interval handles the timing
        }

        function showLoadingIndicator(message = 'Loading...', persistent = false) {
            const indicator = document.createElement('div');
            indicator.className = 'ajax-loading-indicator';
            indicator.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: var(--card-bg);
                border: 1px solid var(--border-color);
                border-radius: 8px;
                padding: 1rem 1.5rem;
                z-index: 1000;
                display: flex;
                align-items: center;
                gap: 0.75rem;
                color: var(--text-primary);
                font-size: 0.875rem;
                box-shadow: var(--shadow-lg);
            `;
            indicator.innerHTML = `
                <div class="loading"></div>
                <span>${message}</span>
            `;
            document.body.appendChild(indicator);

            if (!persistent) {
                setTimeout(() => {
                    if (indicator.parentNode) {
                        indicator.remove();
                    }
                }, 3000);
            }

            return indicator;
        }

        function showSuccessToast(message) {
            const toast = document.createElement('div');
            toast.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: var(--success-color);
                color: white;
                border-radius: 8px;
                padding: 1rem 1.5rem;
                z-index: 1001;
                font-size: 0.875rem;
                box-shadow: var(--shadow-lg);
            `;
            toast.textContent = message;
            document.body.appendChild(toast);

            setTimeout(() => {
                toast.remove();
            }, 3000);
        }

        function showErrorToast(message) {
            const toast = document.createElement('div');
            toast.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: var(--danger-color);
                color: white;
                border-radius: 8px;
                padding: 1rem 1.5rem;
                z-index: 1001;
                font-size: 0.875rem;
                box-shadow: var(--shadow-lg);
            `;
            toast.textContent = message;
            document.body.appendChild(toast);

            setTimeout(() => {
                toast.remove();
            }, 5000);
        }

        function openProduct(button) {
            const url = button.getAttribute('data-url');
            console.log('Opening product:', url);

            if (!url) {
                console.error('No URL found in button data-url attribute');
                return;
            }

            try {
                // Try to open in new tab
                const newWindow = window.open(url, '_blank', 'noopener,noreferrer');

                if (newWindow) {
                    console.log('Product page opened successfully');
                    newWindow.focus();
                } else {
                    console.warn('Popup blocked - copying URL to clipboard');
                    // Alternative: Copy URL to clipboard silently
                    copyToClipboardFromUrl(url);
                }
            } catch (error) {
                console.error('Error opening product page:', error);
                // Fallback: Copy URL silently
                copyToClipboardFromUrl(url);
            }
        }

        function copyToClipboardFromUrl(url) {
            navigator.clipboard.writeText(url).then(function() {
                console.log('URL copied to clipboard:', url);
            }).catch(function(err) {
                console.error('Failed to copy URL:', err);
                // Fallback method for older browsers
                const textArea = document.createElement('textarea');
                textArea.value = url;
                document.body.appendChild(textArea);
                textArea.select();
                document.execCommand('copy');
                document.body.removeChild(textArea);
                console.log('URL copied using fallback method');
            });
        }

        // Enhanced Timer System with SSE Integration
        function initializeTimer() {
            console.log('ðŸ”„ Initializing SSE-based timer system...');

            // Sync with server first, then start countdown
            if (countdownElement) {
                syncTimerWithServer(); // This will start the countdown after sync
                console.log('âœ… Real-time timer initialized (no page refreshes)');
            } else {
                console.error('âŒ Failed to find countdown element');
            }
        }

        // Sync timer with server (ONLY on page load/refresh)
        // POLLING VERSION - Waits for monitoring to start before syncing timer
        function syncTimerWithServer() {
            // Only sync once on page load or manual refresh - never during countdown
            if (lastServerSync > 0) {
                console.log('â­ï¸ Timer already synced, skipping to maintain independent countdown');
                return;
            }

            lastServerSync = Date.now();

            // Show "waiting for monitoring" state
            if (countdownElement) {
                countdownElement.textContent = '...';
                countdownElement.style.opacity = '0.5';
            }
            console.log('â³ Waiting for monitoring to start...');

            // Poll every second until monitoring becomes active
            function pollForTimer() {
                fetch('/api/timer-status')
                    .then(response => response.json())
                    .then(data => {
                        if (data.active && data.start_time) {
                            // âœ… Monitoring started! Sync with real backend values
                            timerStartTime = data.start_time;
                            timerDuration = data.total;
                            countdown = Math.ceil(data.remaining);

                            console.log(`âœ… Monitoring active! Timer synced with backend:`);
                            console.log(`   - Start time: ${timerStartTime}`);
                            console.log(`   - Duration: ${timerDuration}s (random 15-25s)`);
                            console.log(`   - Remaining: ${countdown}s`);

                            // Restore normal opacity and show countdown
                            if (countdownElement) {
                                countdownElement.textContent = countdown;
                                countdownElement.style.opacity = '1';
                            }

                            // Start countdown interval (1 second updates)
                            if (countdownInterval) {
                                clearInterval(countdownInterval);
                            }
                            countdownInterval = setInterval(updateCountdown, 1000);
                            console.log('âœ… Countdown interval started - timer and API now synchronized!');
                        } else {
                            // â³ Not active yet, poll again in 1 second
                            console.log('â³ Monitoring not started yet, polling again in 1s...');
                            setTimeout(pollForTimer, 1000);
                        }
                    })
                    .catch(error => {
                        // âŒ Error fetching status, retry in 2 seconds
                        console.warn('âš ï¸ Timer status fetch failed, retrying in 2s:', error);
                        setTimeout(pollForTimer, 2000);
                    });
            }

            // Start polling
            pollForTimer();
        }

        // ===============================================
        // BULLETPROOF REAL-TIME SYSTEM - SERVER-SENT EVENTS
        // ===============================================

        let eventSource = null;
        const activeCountdowns = {};

        // FIX #3: Initialization guard (SAFETY)
        let realTimeUpdatesInitialized = false;

        // SSE Fallback and Recovery Configuration
        let sseFailureCount = 0;
        let lastSSEEventTime = Date.now();
        let pollingFallbackActive = false;
        let pollingInterval = null;
        let sseHealthCheckInterval = null;
        const MAX_SSE_FAILURES = 3;
        const SSE_TIMEOUT_MS = 30000; // 30 seconds without events triggers fallback
        const POLLING_INTERVAL_MS = 5000; // 5 second polling fallback
        const SSE_HEALTH_CHECK_MS = 10000; // Check SSE health every 10 seconds

        async function initializeRealTimeUpdates() {
            // FIX #3: Initialization guard (SAFETY)
            // Prevent multiple initializations from duplicate event listeners or manual calls
            if (realTimeUpdatesInitialized) {
                console.log('âš ï¸ Real-time updates already initialized, skipping duplicate initialization');
                return;
            }

            console.log('ðŸš€ BULLETPROOF: Initializing real-time updates with fallback mechanisms...');

            // CRITICAL FIX: Fetch initial data BEFORE SSE connection
            // This prevents dashboard from being stuck on "LOADING..." if SSE is slow/fails
            console.log('ðŸ“¥ Fetching initial dashboard state...');
            try {
                const response = await fetch('/api/current-state');
                if (response.ok) {
                    const data = await response.json();
                    console.log('âœ… Initial data loaded:', data);

                    // Populate stock data from initial fetch
                    if (data.stock_data) {
                        Object.entries(data.stock_data).forEach(([tcin, stockInfo]) => {
                            updateStockStatus(tcin, stockInfo);
                        });
                        console.log(`âœ… Pre-populated ${Object.keys(data.stock_data).length} products`);
                    }

                    // Update purchase states
                    if (data.purchase_states) {
                        Object.entries(data.purchase_states).forEach(([tcin, state]) => {
                            updatePurchaseStatus(tcin, state.status, state);
                        });
                    }

                    // FIX #1: Process activity log from initial fetch (CRITICAL)
                    // Backend sends activity_log array in /api/current-state response
                    // This ensures activity log displays stock check results on page load
                    if (data.activity_log && Array.isArray(data.activity_log)) {
                        console.log(`âœ… INITIAL FETCH: Loading ${data.activity_log.length} activity log entries`);
                        data.activity_log.forEach(entry => {
                            addActivityEntryToDOM(entry);
                        });
                    } else {
                        console.log('âš ï¸ INITIAL FETCH: No activity_log in response');
                    }
                } else {
                    console.warn('âš ï¸ Failed to fetch initial data:', response.status);
                }
            } catch (error) {
                console.error('âŒ Failed to fetch initial data:', error);
                // Continue anyway - SSE will provide updates
            }

            // Start SSE health monitoring
            startSSEHealthMonitoring();

            // Connect to SSE stream with enhanced error handling
            connectSSE();

            // FIX #3: Mark initialization as complete (SAFETY)
            realTimeUpdatesInitialized = true;
            console.log('âœ… Real-time updates initialization complete');
        }

        function connectSSE() {
            try {
                // Clean up existing connection
                if (eventSource) {
                    eventSource.close();
                    eventSource = null;
                }

                console.log('ðŸ”Œ Establishing SSE connection...');
                eventSource = new EventSource('/api/stream');

                eventSource.onopen = function(event) {
                    console.log('âœ… SSE connection established');
                    updateConnectionStatus(true);
                    sseFailureCount = 0; // Reset failure count on successful connection
                    lastSSEEventTime = Date.now(); // Reset timeout tracker

                    // If polling fallback was active, disable it
                    if (pollingFallbackActive) {
                        disablePollingFallback();
                    }

                    // FIX #2: Post-SSE state refresh (IMPORTANT)
                    // Immediately fetch current state after SSE connects to catch any updates
                    // that may have occurred before the connection was fully established
                    console.log('ðŸ”„ Fetching current state post-SSE connection...');
                    fetch('/api/current-state')
                        .then(response => response.json())
                        .then(data => {
                            console.log('ðŸ“¥ Post-SSE connection state refresh:', data);
                            if (data.stock_data && Object.keys(data.stock_data).length > 0) {
                                console.log(`âœ“ Applying stock data for ${Object.keys(data.stock_data).length} products`);
                                Object.entries(data.stock_data).forEach(([tcin, stockInfo]) => {
                                    updateStockStatus(tcin, stockInfo);
                                });
                            } else {
                                console.log('âš  Post-SSE refresh: No stock data available yet');
                            }
                        })
                        .catch(error => {
                            console.error('âŒ Post-SSE state refresh failed:', error);
                        });
                };

                eventSource.onmessage = function(event) {
                    try {
                        lastSSEEventTime = Date.now(); // Update last event time
                        const data = JSON.parse(event.data);

                        // DIAGNOSTIC FIX: Log every SSE event received
                        console.log('ðŸ“¡ SSE EVENT RECEIVED:', {
                            type: data.type,
                            timestamp: data.timestamp,
                            hasData: !!data.data,
                            dataKeys: data.data ? Object.keys(data.data) : []
                        });

                        // Enhanced event handling with fallback tracking
                        handleRealTimeEventWithFallback(data);

                    } catch (error) {
                        console.error('âŒ Failed to parse SSE data:', error);
                        console.error('Raw event data:', event.data);
                        handleSSEFailure('Parse error', error);
                    }
                };

                eventSource.onerror = function(event) {
                    console.error('âŒ SSE connection error:', event);
                    console.error('âŒ SSE readyState:', eventSource?.readyState);
                    console.error('âŒ SSE url:', eventSource?.url);

                    // Log detailed error information
                    const errorDetails = {
                        readyState: eventSource?.readyState,
                        url: eventSource?.url,
                        type: event.type,
                        timestamp: new Date().toISOString()
                    };
                    console.error('âŒ SSE ERROR DETAILS:', errorDetails);

                    handleSSEFailure('Connection error', event);
                };

            } catch (error) {
                console.error('âŒ Failed to initialize SSE:', error);
                handleSSEFailure('Initialization error', error);
            }
        }

        function handleSSEFailure(reason, event) {
            sseFailureCount++;
            console.error(`âŒ SSE FAILURE #${sseFailureCount}: ${reason}`, event);
            updateConnectionStatus(false);

            // Log failure for visibility
            addActivityEntryToDOM({
                level: 'error',
                message: `Real-time connection failed: ${reason} (failure #${sseFailureCount})`,
                time_str: new Date().toLocaleTimeString()
            });

            // Decide on recovery strategy based on failure count
            if (sseFailureCount >= MAX_SSE_FAILURES) {
                console.warn(`âš ï¸ SSE FAILURE THRESHOLD REACHED: Enabling polling fallback`);
                enablePollingFallback();
            } else {
                // Exponential backoff for reconnection
                const retryDelay = Math.min(3000 * Math.pow(2, sseFailureCount - 1), 30000);
                console.log(`ðŸ”„ SSE RECONNECTION: Retrying in ${retryDelay}ms (attempt ${sseFailureCount}/${MAX_SSE_FAILURES})`);

                setTimeout(() => {
                    if (!pollingFallbackActive && sseFailureCount < MAX_SSE_FAILURES) {
                        connectSSE();
                    }
                }, retryDelay);
            }
        }

        function enablePollingFallback() {
            if (pollingFallbackActive) return;

            console.log('ðŸ”„ ENABLING POLLING FALLBACK: SSE unreliable, switching to polling mode');
            pollingFallbackActive = true;

            // Close SSE connection
            if (eventSource) {
                eventSource.close();
                eventSource = null;
            }

            // Start polling for updates
            pollingInterval = setInterval(async () => {
                try {
                    console.log('ðŸ“¡ POLLING: Fetching update via fallback...');
                    const response = await fetch('/api/current-state');
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }

                    const data = await response.json();
                    handlePollingUpdate(data);

                } catch (error) {
                    console.error('âŒ POLLING FALLBACK FAILED:', error);
                    // If polling also fails, try to re-enable SSE
                    if (sseFailureCount >= MAX_SSE_FAILURES + 3) {
                        console.log('ðŸ”„ POLLING FAILED: Attempting SSE recovery...');
                        disablePollingFallback();
                        sseFailureCount = 0; // Reset and try SSE again
                        connectSSE();
                    }
                }
            }, POLLING_INTERVAL_MS);

            // Update UI to show polling mode
            updateConnectionStatus('polling');

            addActivityEntryToDOM({
                level: 'warning',
                message: 'Switched to polling mode due to connection issues',
                time_str: new Date().toLocaleTimeString()
            });
        }

        function disablePollingFallback() {
            console.log('âœ… DISABLING POLLING FALLBACK: SSE connection restored');
            pollingFallbackActive = false;

            if (pollingInterval) {
                clearInterval(pollingInterval);
                pollingInterval = null;
            }
        }

        function startSSEHealthMonitoring() {
            // Monitor SSE health by checking last event time
            sseHealthCheckInterval = setInterval(() => {
                if (pollingFallbackActive) return; // Skip if already in fallback mode

                const timeSinceLastEvent = Date.now() - lastSSEEventTime;

                if (timeSinceLastEvent > SSE_TIMEOUT_MS) {
                    console.warn(`âš ï¸ SSE TIMEOUT: No events for ${timeSinceLastEvent}ms, checking connection...`);

                    // Test if SSE is actually dead by checking readyState
                    if (eventSource && eventSource.readyState === EventSource.CLOSED) {
                        console.error('âŒ SSE CONNECTION DEAD: Auto-recovering...');
                        handleSSEFailure('Timeout - connection dead', null);
                    } else if (timeSinceLastEvent > SSE_TIMEOUT_MS * 2) {
                        // If no events for double the timeout, force reconnection
                        console.error('âŒ SSE FORCED RECOVERY: Extended timeout detected');
                        handleSSEFailure('Extended timeout', null);
                    }
                }
            }, SSE_HEALTH_CHECK_MS);
        }

        function handlePollingUpdate(data) {
            console.log('ðŸ“¡ POLLING UPDATE RECEIVED:', data);

            // FIX #3: Enhanced polling validation (SAFETY NET)
            // Ensure fallback validates and applies stock data updates even if SSE fails completely

            // Validate data structure
            if (!data || typeof data !== 'object') {
                console.error('âŒ POLLING: Invalid data structure received', data);
                return;
            }

            // Process polling data similar to SSE events
            if (data.stock_data && typeof data.stock_data === 'object') {
                const stockEntries = Object.entries(data.stock_data);
                console.log(`âœ“ POLLING: Processing ${stockEntries.length} stock entries`);

                let successCount = 0;
                let failCount = 0;

                stockEntries.forEach(([tcin, stockInfo]) => {
                    try {
                        const updateResult = updateStockStatus(tcin, stockInfo);
                        if (updateResult) {
                            successCount++;
                        } else {
                            failCount++;
                            console.warn(`âš ï¸ POLLING: Stock update failed for ${tcin}`);
                        }
                    } catch (error) {
                        failCount++;
                        console.error(`âŒ POLLING: Error updating ${tcin}:`, error);
                    }
                });

                console.log(`âœ“ POLLING: Updated ${successCount} products (${failCount} failed)`);
            } else {
                console.log('âš  POLLING: No stock_data in response or invalid format');
            }

            // Update statistics
            if (data.in_stock_count !== undefined) {
                const inStockElement = document.querySelector('.status-card.warning .status-card-value');
                if (inStockElement) {
                    inStockElement.textContent = data.in_stock_count;
                    console.log(`âœ“ POLLING: Updated in_stock_count to ${data.in_stock_count}`);
                }
            }

            // FIX #2: Process activity log from polling updates (CRITICAL)
            // When SSE fails and polling fallback is active, activity log must still update
            // This ensures stock check results appear in activity log even in polling mode
            if (data.activity_log && Array.isArray(data.activity_log)) {
                console.log(`âœ“ POLLING: Processing ${data.activity_log.length} activity log entries`);
                data.activity_log.forEach(entry => {
                    addActivityEntryToDOM(entry);
                });
            } else {
                console.log('âš ï¸ POLLING: No activity_log in response');
            }

            // Update last update time
            const lastUpdateElement = document.querySelector('.header-stat-value');
            if (lastUpdateElement && lastUpdateElement.closest('.header-stat').querySelector('.header-stat-label').textContent === 'Last Update') {
                const now = new Date();
                lastUpdateElement.textContent = now.toLocaleTimeString();
                console.log(`âœ“ POLLING: Updated last update time to ${now.toLocaleTimeString()}`);

                // FIX #3: Show visual feedback that polling update occurred
                // Users expect to see that "something happened" even when stock status doesn't change
                if (successCount > 0 || failCount > 0) {
                    showPollingUpdateToast(successCount, failCount);
                }
            }
        }

        // FIX #3: Visual feedback toast for polling updates
        // Displays subtle notification when polling refreshes data
        // Helps users know the dashboard is actively updating without manual refresh
        function showPollingUpdateToast(successCount, failCount) {
            // Remove any existing toast
            const existingToast = document.querySelector('.polling-toast');
            if (existingToast) {
                existingToast.remove();
            }

            // Create new toast notification
            const toast = document.createElement('div');
            toast.className = 'polling-toast';

            // Build message based on success/fail counts
            let message = '';
            if (successCount > 0 && failCount === 0) {
                message = `âœ“ Updated ${successCount} product${successCount > 1 ? 's' : ''}`;
                toast.style.background = '#28a745';
            } else if (successCount > 0 && failCount > 0) {
                message = `âš  Updated ${successCount}, ${failCount} failed`;
                toast.style.background = '#ffc107';
                toast.style.color = '#000';
            } else if (failCount > 0) {
                message = `âœ— ${failCount} update${failCount > 1 ? 's' : ''} failed`;
                toast.style.background = '#dc3545';
            }

            toast.textContent = message;
            toast.style.cssText += `
                position: fixed;
                bottom: 20px;
                right: 20px;
                color: white;
                padding: 12px 24px;
                border-radius: 8px;
                z-index: 9999;
                font-size: 14px;
                font-weight: 500;
                box-shadow: 0 4px 12px rgba(0,0,0,0.15);
                animation: fadeInOut 3s ease-in-out;
                pointer-events: none;
            `;

            // Add CSS animation if not already present
            if (!document.querySelector('#polling-toast-styles')) {
                const style = document.createElement('style');
                style.id = 'polling-toast-styles';
                style.textContent = `
                    @keyframes fadeInOut {
                        0% { opacity: 0; transform: translateY(20px); }
                        10% { opacity: 1; transform: translateY(0); }
                        90% { opacity: 1; transform: translateY(0); }
                        100% { opacity: 0; transform: translateY(20px); }
                    }
                `;
                document.head.appendChild(style);
            }

            document.body.appendChild(toast);

            // Remove toast after animation completes
            setTimeout(() => {
                if (toast.parentNode) {
                    toast.remove();
                }
            }, 3000);
        }

        function handleRealTimeEventWithFallback(data) {
            try {
                // Process the event normally
                handleRealTimeEvent(data);

                // Additional validation for critical events
                if (data.type === 'api_cycle_complete') {
                    validateEventProcessing(data);
                }

            } catch (error) {
                console.error('âŒ EVENT PROCESSING FAILED:', error, data);

                // Attempt recovery for critical stock updates
                if (data.type === 'api_cycle_complete' && data.data && data.data.stock_updates) {
                    console.log('ðŸ”„ ATTEMPTING EVENT RECOVERY...');
                    setTimeout(() => {
                        try {
                            Object.entries(data.data.stock_updates).forEach(([tcin, stockInfo]) => {
                                updateStockStatus(tcin, stockInfo);
                            });
                        } catch (recoveryError) {
                            console.error('âŒ EVENT RECOVERY FAILED:', recoveryError);
                        }
                    }, 1000);
                }
            }
        }

        function validateEventProcessing(eventData) {
            // Ensure stock updates were actually processed
            if (eventData.data && eventData.data.stock_updates) {
                setTimeout(() => {
                    Object.entries(eventData.data.stock_updates).forEach(([tcin, stockInfo]) => {
                        const currentStatus = getStockStatusFromUI(tcin);
                        const expectedStatus = stockInfo.in_stock ? 'IN_STOCK' : 'OUT_OF_STOCK';

                        if (currentStatus !== expectedStatus) {
                            console.warn(`âš ï¸ EVENT VALIDATION FAILED: ${tcin} expected ${expectedStatus}, got ${currentStatus}`);
                            // Trigger recovery update
                            updateStockStatus(tcin, stockInfo);
                        }
                    });
                }, 200);
            }
        }

        function handleRealTimeEvent(data) {
            switch (data.type) {
                case 'api_cycle_complete':
                    handleAtomicApiCycleUpdate(data);
                    break;
                case 'metric_update':
                    handleMetricUpdate(data.data);
                    break;
                case 'purchase_status':
                    handlePurchaseStatusUpdate(data.data);
                    break;
                case 'stock_update':
                    handleStockUpdate(data.data);
                    break;
                case 'activity_log':
                    handleActivityLogUpdate(data.data);
                    break;
                case 'logs_cleared':
                    handleLogsClearedUpdate(data.data);
                    break;
                case 'timer_sync':
                    handleTimerSync(data.data);
                    break;
                case 'refresh_cycle':
                    handleRefreshCycle(data.data);
                    break;
                case 'heartbeat':
                    // Keep connection alive
                    break;
                default:
                    console.log('ðŸ“¡ Real-time event:', data.type, data.data);
            }
        }

        function handleMetricUpdate(data) {
            // Update Total Products metric
            if (data.total_products !== undefined) {
                const totalProductsMetric = document.querySelector('#metric-total-products .metric-value');
                if (totalProductsMetric) {
                    totalProductsMetric.textContent = data.total_products;
                    console.log(`ðŸ“Š INSTANT UPDATE: Total products = ${data.total_products}`);
                }

                // Update header stat
                const headerProductsStat = document.querySelectorAll('.header-stat');
                headerProductsStat.forEach(stat => {
                    const label = stat.querySelector('.header-stat-label');
                    if (label && label.textContent === 'Products') {
                        const value = stat.querySelector('.header-stat-value');
                        if (value) {
                            value.textContent = data.total_products;
                        }
                    }
                });
            }

            // Update In Stock metric
            if (data.in_stock_count !== undefined) {
                const inStockMetric = document.querySelector('#metric-in-stock .metric-value');
                if (inStockMetric) {
                    inStockMetric.textContent = data.in_stock_count;
                    console.log(`ðŸ“Š INSTANT UPDATE: In stock = ${data.in_stock_count}`);
                }
            }
        }

        function handleAtomicApiCycleUpdate(eventData) {
            /**
             * ATOMIC API CYCLE HANDLER - Processes entire 15-25s cycle atomically
             * This prevents intermediate UI states and ensures all changes happen simultaneously
             */
            console.log(`ðŸ”„ ATOMIC: Processing API cycle ${eventData.cycle_id}`);
            console.log(`ðŸ“Š CYCLE DATA:`, eventData);

            const cycleData = eventData.data;
            const stockUpdates = cycleData.stock_updates || {};
            const purchaseChanges = cycleData.purchase_state_changes || {};
            const timerSync = cycleData.timer_sync || {};
            const summary = cycleData.summary || {};

            // VALIDATION: Log state BEFORE changes for comparison
            const preUpdateState = validateCurrentUIState();
            console.log(`ðŸ“‹ PRE-UPDATE UI STATE:`, preUpdateState);

            // STEP 1: Update timer FIRST (critical for sync)
            if (timerSync.current_remaining !== undefined) {
                const oldCountdown = countdown;
                const newCountdown = Math.ceil(timerSync.current_remaining);

                // Update timer reference for accurate calculation
                if (timerSync.total_duration !== undefined) {
                    const now = Date.now() / 1000;
                    timerDuration = timerSync.total_duration;
                    // Calculate when the cycle started: now - elapsed
                    const elapsed = timerDuration - timerSync.current_remaining;
                    timerStartTime = now - elapsed;
                    console.log(`ðŸ”„ ATOMIC: Timer updated - start=${timerStartTime}, duration=${timerDuration}, remaining=${newCountdown}s`);
                }

                // IMPROVED TIMER DRIFT DETECTION - with validation
                const shouldMeasureDrift = validateTimerMeasurement(oldCountdown, newCountdown, eventData.cycle_id);

                if (shouldMeasureDrift) {
                    const drift = Math.abs(oldCountdown - newCountdown);
                    if (drift > 3) { // Increased threshold to reduce false positives
                        console.warn(`â° TIMER DRIFT DETECTED: Frontend was ${oldCountdown}s, Backend says ${newCountdown}s (drift: ${drift}s)`);
                        logTimerDrift(oldCountdown, newCountdown, drift, eventData.cycle_id);
                    } else if (drift > 1) {
                        console.log(`â° Minor timer adjustment: ${oldCountdown}s â†’ ${newCountdown}s (${drift}s difference)`);
                    }
                } else {
                    console.log(`â° Timer measurement skipped - invalid baseline (Frontend: ${oldCountdown}s, Backend: ${newCountdown}s)`);
                }

                countdown = newCountdown;
                isRefreshing = false;
                if (countdownElement) {
                    countdownElement.textContent = countdown;
                    countdownElement.classList.remove('refreshing');
                }
                console.log(`ðŸ”„ ATOMIC: Timer synced to ${countdown}s`);
            }

            // STEP 2: Process purchase resets atomically
            // SIMPLIFIED: Just reset status badge to ready
            // Last Attempt column is separate and persistent (never reset)
            const resetTcins = purchaseChanges.resets || [];
            resetTcins.forEach(tcin => {
                updatePurchaseStatus(tcin, 'ready', {});
                // Clear any existing countdown for this TCIN
                if (activeCountdowns[tcin]) {
                    clearInterval(activeCountdowns[tcin]);
                    delete activeCountdowns[tcin];
                }
            });
            if (resetTcins.length > 0) {
                console.log(`ðŸ”„ ATOMIC: Reset ${resetTcins.length} purchase states to ready (Last Attempt preserved)`);
            }

            // STEP 3: Update stock statuses atomically with enhanced error handling
            console.log(`ðŸ“¦ STOCK UPDATES PROCESSING (${Object.keys(stockUpdates).length} updates):`);
            const stockUpdateResults = {
                successful: 0,
                failed: 0,
                retrying: 0,
                errors: []
            };

            Object.entries(stockUpdates).forEach(([tcin, stockInfo]) => {
                try {
                    const oldStatus = getStockStatusFromUI(tcin);
                    console.log(`ðŸ“¦ PROCESSING STOCK UPDATE: ${tcin} - ${oldStatus} -> ${stockInfo.in_stock ? 'IN_STOCK' : 'OUT_OF_STOCK'}`);

                    // Enhanced updateStockStatus call with result tracking
                    const updateResult = updateStockStatus(tcin, stockInfo);

                    if (updateResult === true) {
                        stockUpdateResults.successful++;
                        const newStatus = stockInfo.in_stock ? 'IN_STOCK' : 'OUT_OF_STOCK';

                        // LOG CRITICAL BUG SCENARIO: Stock status changes
                        if (oldStatus !== newStatus) {
                            console.log(`ðŸ”„ STOCK CHANGE CONFIRMED: ${tcin} ${oldStatus} â†’ ${newStatus}`);
                            console.log(`ðŸ“Š Stock Info:`, stockInfo);
                        }
                    } else if (updateResult === false) {
                        // Check if it's a retry or permanent failure
                        if (stockUpdateRetries.has(tcin)) {
                            stockUpdateResults.retrying++;
                            console.log(`ðŸ”„ STOCK UPDATE RETRYING: ${tcin} (attempt ${stockUpdateRetries.get(tcin)})`);
                        } else {
                            stockUpdateResults.failed++;
                            const error = `Stock update failed for ${tcin}`;
                            stockUpdateResults.errors.push(error);
                            console.error(`âŒ STOCK UPDATE FAILED: ${tcin}`);
                        }
                    }

                    // Additional validation: Check DOM state after update
                    setTimeout(() => {
                        const finalStatus = getStockStatusFromUI(tcin);
                        const expectedStatus = stockInfo.in_stock ? 'IN_STOCK' : 'OUT_OF_STOCK';

                        if (finalStatus !== expectedStatus) {
                            console.error(`âŒ DELAYED VALIDATION FAILED: ${tcin} Expected ${expectedStatus}, got ${finalStatus}`);
                            // Attempt one more recovery update
                            console.log(`ðŸ”„ RECOVERY UPDATE ATTEMPT: ${tcin}`);
                            updateStockStatus(tcin, stockInfo);
                        }
                    }, 100); // Check after 100ms to allow for any async operations

                } catch (error) {
                    stockUpdateResults.failed++;
                    const errorMsg = `Exception in stock update for ${tcin}: ${error.message}`;
                    stockUpdateResults.errors.push(errorMsg);
                    console.error(`âŒ STOCK UPDATE EXCEPTION: ${tcin}`, error);

                    // Emergency fallback: Try to mark the element as having an error
                    try {
                        // FIX: Exclude preorder badges - must match selector used everywhere else
                        const stockBadge = document.querySelector(`.badge[data-tcin="${tcin}"]:not(.preorder-badge)`);
                        if (stockBadge) {
                            stockBadge.className = 'badge unknown';
                            stockBadge.textContent = 'âš ï¸ ERROR';
                            stockBadge.title = `Update error: ${error.message}`;
                        }
                    } catch (fallbackError) {
                        console.error(`âŒ EMERGENCY FALLBACK FAILED: ${tcin}`, fallbackError);
                    }
                }
            });

            // Comprehensive logging of stock update results
            console.log(`ðŸ”„ ATOMIC STOCK UPDATE SUMMARY:`, {
                total: Object.keys(stockUpdates).length,
                successful: stockUpdateResults.successful,
                failed: stockUpdateResults.failed,
                retrying: stockUpdateResults.retrying,
                errors: stockUpdateResults.errors
            });

            // Alert if there are significant failures
            if (stockUpdateResults.failed > 0) {
                console.warn(`âš ï¸ STOCK UPDATE ISSUES: ${stockUpdateResults.failed} failed, ${stockUpdateResults.retrying} retrying`);

                // Log to activity for visibility
                addActivityEntryToDOM({
                    level: 'warning',
                    message: `Stock update issues: ${stockUpdateResults.failed} failed, ${stockUpdateResults.retrying} retrying`,
                    time_str: new Date().toLocaleTimeString()
                });
            }

            // STEP 4: Start new purchase attempts atomically
            // SIMPLIFIED: Just update status badge to attempting
            // Last Attempt column is separate and persistent
            const newAttempts = purchaseChanges.new_attempts || [];
            newAttempts.forEach(attempt => {
                updatePurchaseStatus(attempt.tcin, 'attempting', attempt);
                if (attempt.completes_at) {
                    startRealTimeCountdown(attempt.tcin, attempt);
                }
            });
            if (newAttempts.length > 0) {
                console.log(`ðŸ”„ ATOMIC: Started ${newAttempts.length} purchase attempts (Last Attempt preserved)`);
            }

            // STEP 5: Update header statistics and metric cards
            if (summary.in_stock_count !== undefined) {
                // Update the In Stock metric card (FIX: Use correct selector)
                const inStockMetric = document.querySelector('#metric-in-stock .metric-value');
                if (inStockMetric) {
                    inStockMetric.textContent = summary.in_stock_count;
                    console.log(`ðŸ“Š METRIC UPDATE: In Stock count updated to ${summary.in_stock_count}`);
                } else {
                    console.warn('âš ï¸ METRIC UPDATE: #metric-in-stock .metric-value not found');
                }
            }

            if (summary.total_products !== undefined) {
                // Update the Total Products metric card (NEW: Was missing)
                const totalProductsMetric = document.querySelector('#metric-total-products .metric-value');
                if (totalProductsMetric) {
                    totalProductsMetric.textContent = summary.total_products;
                    console.log(`ðŸ“Š METRIC UPDATE: Total products updated to ${summary.total_products}`);
                } else {
                    console.warn('âš ï¸ METRIC UPDATE: #metric-total-products .metric-value not found');
                }

                // Update the header stat for Products (in the top right)
                const headerProductsStat = document.querySelectorAll('.header-stat');
                headerProductsStat.forEach(stat => {
                    const label = stat.querySelector('.header-stat-label');
                    if (label && label.textContent === 'Products') {
                        const value = stat.querySelector('.header-stat-value');
                        if (value) {
                            value.textContent = summary.total_products;
                            console.log(`ðŸ“Š HEADER UPDATE: Products count updated to ${summary.total_products}`);
                        }
                    }
                });
            }

            // STEP 5.5: BUGFIX - Update activity log from SSE event
            if (cycleData.activity_log && Array.isArray(cycleData.activity_log)) {
                const logContainer = document.querySelector('.log-container');
                if (logContainer) {
                    // Clear and reload activity log to avoid duplicates
                    logContainer.innerHTML = '';
                    cycleData.activity_log.forEach(entry => {
                        addActivityEntryToDOM(entry);
                    });
                    console.log(`ðŸ”„ ATOMIC: Updated activity log (${cycleData.activity_log.length} entries)`);
                } else {
                    console.warn('âš ï¸ ATOMIC: Log container not found, cannot update activity log');
                }
            } else {
                console.log('ðŸ”„ ATOMIC: No activity_log in event data (older backend version?)');
            }

            // STEP 6: Update last update time in header
            const lastUpdateElement = document.querySelector('.header-stat-value');
            if (lastUpdateElement && lastUpdateElement.closest('.header-stat').querySelector('.header-stat-label').textContent === 'Last Update') {
                const now = new Date();
                lastUpdateElement.textContent = now.toLocaleTimeString();
            }

            // FINAL VALIDATION: Compare UI state after processing
            const postUpdateState = validateCurrentUIState();
            console.log(`ðŸ“‹ POST-UPDATE UI STATE:`, postUpdateState);

            // SYNC VALIDATION: Check if UI matches expected backend state
            validateSyncWithBackend(stockUpdates, purchaseChanges, eventData.cycle_id);

            console.log(`âœ… ATOMIC: API cycle ${eventData.cycle_id} processed completely - ${summary.total_products} products, ${summary.in_stock_count} in stock, ${summary.new_attempts_count} attempts, ${summary.resets_count} resets`);
        }

        function validateCurrentUIState() {
            /**
             * SYNC VALIDATION: Capture current UI state for comparison
             */
            const uiState = {};

            // Get all product rows
            const productRows = document.querySelectorAll('tr[data-tcin]');
            productRows.forEach(row => {
                const tcin = row.getAttribute('data-tcin');
                // FIX: Exclude preorder badges - must match selector used in updateStockStatus()
                const stockBadge = row.querySelector('.badge[data-tcin]:not(.preorder-badge)');
                const purchaseBadge = row.querySelector(`#purchase-status-${tcin}`);

                uiState[tcin] = {
                    stock_status: stockBadge ? stockBadge.textContent.trim() : 'UNKNOWN',
                    stock_classes: stockBadge ? stockBadge.className : '',
                    purchase_status: purchaseBadge ? purchaseBadge.textContent.trim() : 'UNKNOWN',
                    purchase_classes: purchaseBadge ? purchaseBadge.className : ''
                };
            });

            return uiState;
        }

        function getStockStatusFromUI(tcin) {
            /**
             * Get current stock status for a specific TCIN from UI
             */
            // FIX: Exclude preorder badges - must match selector used in updateStockStatus()
            const stockBadge = document.querySelector(`.badge[data-tcin="${tcin}"]:not(.preorder-badge)`);
            if (!stockBadge) return 'UNKNOWN';

            const text = stockBadge.textContent.trim();
            if (text.includes('IN STOCK')) return 'IN_STOCK';
            if (text.includes('OUT OF STOCK')) return 'OUT_OF_STOCK';
            if (text.includes('LOADING')) return 'LOADING';
            if (text.includes('WAITING')) return 'WAITING';
            return text;
        }

        function validateSyncWithBackend(stockUpdates, purchaseChanges, cycleId) {
            /**
             * CRITICAL: Validate that UI state matches what backend sent
             * This catches the specific bug: backend says IN_STOCK but UI shows OUT_OF_STOCK
             */
            console.log(`ðŸ” SYNC VALIDATION for cycle ${cycleId}:`);

            let syncErrors = [];

            // Validate stock status sync
            Object.entries(stockUpdates).forEach(([tcin, backendStock]) => {
                const uiStatus = getStockStatusFromUI(tcin);
                const expectedStatus = backendStock.in_stock ? 'IN_STOCK' : 'OUT_OF_STOCK';

                if (uiStatus !== expectedStatus) {
                    const error = `âŒ SYNC ERROR: ${tcin} Backend=${expectedStatus} UI=${uiStatus}`;
                    console.error(error);
                    syncErrors.push(error);
                }
            });

            // Validate purchase status sync
            const resetTcins = purchaseChanges.resets || [];
            resetTcins.forEach(tcin => {
                const purchaseBadge = document.querySelector(`#purchase-status-${tcin}`);
                if (purchaseBadge && !purchaseBadge.textContent.includes('READY')) {
                    const error = `âŒ SYNC ERROR: ${tcin} should be READY after reset, but shows ${purchaseBadge.textContent}`;
                    console.error(error);
                    syncErrors.push(error);
                }
            });

            if (syncErrors.length === 0) {
                console.log(`âœ… SYNC PERFECT: All UI states match backend for cycle ${cycleId}`);
            } else {
                console.error(`ðŸš¨ SYNC ISSUES DETECTED (${syncErrors.length}):`, syncErrors);
                // Could trigger alert or notification here for immediate debugging
            }

            return syncErrors;
        }

        function handleTimerSync(data) {
            if (data.remaining !== undefined && (isRefreshing || Math.abs(countdown - data.remaining) > 3)) {
                // Only sync if we're refreshing or if there's a significant difference
                countdown = Math.ceil(data.remaining);

                // Update timer reference if available
                if (data.start_time !== undefined && data.total !== undefined) {
                    timerStartTime = data.start_time;
                    timerDuration = data.total;
                    console.log(`ðŸ” Timer synced via SSE: start=${timerStartTime}, duration=${timerDuration}, remaining=${countdown}s`);
                } else if (data.total !== undefined) {
                    // Calculate start time from available data
                    const now = Date.now() / 1000;
                    timerDuration = data.total;
                    const elapsed = timerDuration - data.remaining;
                    timerStartTime = now - elapsed;
                    console.log(`ðŸ” Timer synced via SSE (calculated): start=${timerStartTime}, duration=${timerDuration}, remaining=${countdown}s`);
                } else {
                    console.log(`ðŸ” Timer synced via SSE: ${countdown}s`);
                }

                isRefreshing = false;
                if (countdownElement) {
                    countdownElement.textContent = countdown;
                    countdownElement.classList.remove('refreshing');
                }
            }
        }

        function handleRefreshCycle(data) {
            console.log('ðŸ”„ Refresh cycle completed - data updated via SSE');
            // Reset timer for next cycle
            countdown = REFRESH_INTERVAL;
            isRefreshing = false;
            if (countdownElement) {
                countdownElement.classList.remove('refreshing');
            }
        }

        function handlePurchaseStatusUpdate(data) {
            const tcin = data.tcin;
            const status = data.status;
            const state = data.state;

            console.log(`ðŸ”„ Real-time purchase update: ${tcin} -> ${status}`);

            if (status === 'attempting') {
                // Start countdown for attempting status
                startRealTimeCountdown(tcin, state);
            } else {
                // Clear any existing countdown
                if (activeCountdowns[tcin]) {
                    clearInterval(activeCountdowns[tcin]);
                    delete activeCountdowns[tcin];
                }

                // Update status badge
                updatePurchaseStatus(tcin, status, state);
            }
        }

        function startRealTimeCountdown(tcin, state) {
            const completesAt = state.completes_at;
            if (!completesAt) return;

            // Clear existing countdown and start fresh
            if (activeCountdowns[tcin]) {
                clearInterval(activeCountdowns[tcin]);
            }

            function updateCountdown() {
                const now = Date.now() / 1000;
                const remaining = Math.max(0, Math.ceil(completesAt - now));

                if (remaining > 0) {
                    updatePurchaseStatusWithCountdown(tcin, 'attempting', remaining);
                } else {
                    // Countdown finished - just show "Processing..." and wait for real SSE event
                    // Don't guess the outcome - the backend will send purchase_status event with real result
                    clearInterval(activeCountdowns[tcin]);
                    delete activeCountdowns[tcin];

                    console.log(`â° Countdown expired for ${tcin} - waiting for completion event from backend`);
                    updatePurchaseStatusWithCountdown(tcin, 'attempting', '...');
                }
            }

            // Initial update
            updateCountdown();

            // Start countdown
            activeCountdowns[tcin] = setInterval(updateCountdown, 1000);
        }

        function handleStockUpdate(data) {
            console.log(`ðŸ“Š Real-time stock update: ${data.in_stock_count}/${data.total_count} in stock`);

            // Update header statistics
            const inStockElement = document.querySelector('.status-card.warning .status-card-value');
            if (inStockElement) {
                inStockElement.textContent = data.in_stock_count;
            }

            // Update stock status badges and remove "waiting" states
            Object.entries(data.stock_data).forEach(([tcin, stockInfo]) => {
                updateStockStatus(tcin, stockInfo);
            });

            // Update last update time in header
            const lastUpdateElement = document.querySelector('.header-stat-value');
            if (lastUpdateElement && lastUpdateElement.closest('.header-stat').querySelector('.header-stat-label').textContent === 'Last Update') {
                const now = new Date();
                lastUpdateElement.textContent = now.toLocaleTimeString();
            }
        }

        function handleActivityLogUpdate(entry) {
            // DIAGNOSTIC FIX: Enhanced logging and error handling for activity log updates
            try {
                console.log(`ðŸ“‹ ACTIVITY LOG EVENT RECEIVED:`, entry);
                console.log(`  - Message: ${entry.message}`);
                console.log(`  - Level: ${entry.level}`);
                console.log(`  - Category: ${entry.category}`);
                console.log(`  - Time: ${entry.time_str}`);

                // Validate entry structure
                if (!entry || !entry.message) {
                    console.error('âŒ Invalid activity log entry - missing message:', entry);
                    return;
                }

                // Add to activity log display
                addActivityEntryToDOM(entry);
                console.log('âœ… Activity log entry added to DOM successfully');
            } catch (error) {
                console.error('âŒ Error handling activity log update:', error);
                console.error('Entry that caused error:', entry);
            }
        }

        function handleLogsClearedUpdate(data) {
            console.log(`ðŸ—‘ï¸ Logs cleared: ${data.message}`);

            // Clear the logs from the UI for other connected clients
            const logContainer = document.querySelector('.log-container');
            if (logContainer) {
                logContainer.innerHTML = '<div class="log-entry info"><span style="opacity: 0.7;">[' +
                    new Date().toLocaleTimeString() + ']</span> ðŸ“‹ Activity logs cleared by user</div>';
            }
        }

        function updatePurchaseStatus(tcin, status, state = {}) {
            const badge = document.getElementById(`purchase-status-${tcin}`);
            if (badge) {
                // Simplified: Only show current activity (attempting/ready)
                // Completion results (purchased/failed) now go to Last Attempt column
                let text = '';
                let className = '';

                switch (status) {
                    case 'ready':
                        text = 'âœ… READY';
                        className = 'badge ready';
                        break;
                    case 'attempting':
                        text = 'â³ ATTEMPTING';
                        className = 'badge attempting';
                        break;
                    case 'purchased':
                    case 'failed':
                        // These now update Last Attempt column instead
                        // Set status back to ready after completion
                        text = 'âœ… READY';
                        className = 'badge ready';
                        break;
                    default:
                        text = 'âœ… READY';
                        className = 'badge ready';
                }
                badge.className = className;
                badge.textContent = text;
            }
        }

        function updatePurchaseStatusWithCountdown(tcin, status, remaining) {
            const badge = document.getElementById(`purchase-status-${tcin}`);
            if (badge) {
                badge.className = `badge ${status}`;
                badge.textContent = `â³ ATTEMPTING (${remaining}s)`;
            }
        }

        // Track failed update attempts for retry logic
        const stockUpdateRetries = new Map();
        const MAX_STOCK_UPDATE_RETRIES = 3;
        const STOCK_UPDATE_RETRY_DELAY = 500; // Start with 500ms

        function updateStockStatus(tcin, stockInfo) {
            const updateId = `${tcin}-${Date.now()}`;
            console.log(`ðŸ”„ STOCK UPDATE START: ${updateId} - ${tcin} -> ${stockInfo.in_stock ? 'IN_STOCK' : 'OUT_OF_STOCK'}`);

            try {
                return updateStockStatusWithRetry(tcin, stockInfo, 0, updateId);
            } catch (error) {
                console.error(`âŒ CRITICAL STOCK UPDATE ERROR: ${updateId}`, error);
                // Log to activity for visibility
                addActivityEntryToDOM({
                    level: 'error',
                    message: `Critical stock update error for ${tcin}: ${error.message}`,
                    time_str: new Date().toLocaleTimeString()
                });
                return false;
            }
        }

        function updateStockStatusWithRetry(tcin, stockInfo, attempt, updateId) {
            try {
                console.log(`ðŸ“Š STOCK UPDATE ATTEMPT ${attempt + 1}/${MAX_STOCK_UPDATE_RETRIES}: ${updateId}`);

                // Pre-validation: Check if elements exist (target stock status column specifically)
                // FIX: Exclude preorder badges - only target stock status badges
                // Use :not() to skip preorder-badge class
                const stockBadge = document.querySelector(`.badge[data-tcin="${tcin}"]:not(.preorder-badge)`);
                if (!stockBadge) {
                    // FIX #2: Return false instead of throw - don't let missing badge block other updates
                    // Badge might not be ready yet, will retry on next polling cycle
                    console.warn(`âš ï¸ STOCK UPDATE SKIPPED: ${updateId} - Badge not ready for ${tcin}, will retry on next poll`);
                    return false;
                }

                const productRow = stockBadge.closest('tr');
                if (!productRow) {
                    // FIX #2: Return false instead of throw - defensive coding
                    console.warn(`âš ï¸ STOCK UPDATE SKIPPED: ${updateId} - Row not ready for ${tcin}, will retry on next poll`);
                    return false;
                }

                // Record old state for comparison
                const oldStatus = getStockStatusFromUI(tcin);
                const oldText = stockBadge.textContent;
                const oldClassName = stockBadge.className;

                console.log(`ðŸ“‹ STOCK UPDATE STATE: ${updateId} - Old: ${oldStatus} (${oldText})`);

                // Remove loading animation and waiting state
                stockBadge.classList.remove('unknown');
                const loadingSpinner = stockBadge.querySelector('.loading');
                if (loadingSpinner) {
                    loadingSpinner.remove();
                }

                // Apply new stock status
                const expectedStatus = stockInfo.in_stock ? 'IN_STOCK' : 'OUT_OF_STOCK';
                if (stockInfo.in_stock) {
                    stockBadge.className = 'badge in-stock';
                    stockBadge.textContent = 'IN STOCK';
                } else {
                    stockBadge.className = 'badge out-of-stock';
                    stockBadge.textContent = 'OUT OF STOCK';
                }

                // Immediate validation after update
                const newStatus = getStockStatusFromUI(tcin);
                const newText = stockBadge.textContent;
                const newClassName = stockBadge.className;

                console.log(`ðŸ“‹ STOCK UPDATE RESULT: ${updateId} - New: ${newStatus} (${newText})`);

                // Validation: Check if update was successful
                if (newStatus !== expectedStatus) {
                    const errorMsg = `Stock status validation failed: Expected ${expectedStatus}, got ${newStatus}`;
                    console.error(`âŒ STOCK UPDATE VALIDATION FAILED: ${updateId} - ${errorMsg}`);
                    throw new Error(errorMsg);
                }

                // Update product name if available (OPTIONAL - don't fail if missing)
                try {
                    const productNameCell = document.querySelector(`tr[data-tcin="${tcin}"] .product-name`);

                    // CRITICAL FIX: Make title optional - warn if missing but continue update
                    if (stockInfo.title && stockInfo.title.trim()) {
                        if (productNameCell) {
                            const oldName = productNameCell.textContent;
                            productNameCell.textContent = stockInfo.title;
                            console.log(`ðŸ“ PRODUCT NAME UPDATED: ${updateId} - "${oldName}" -> "${stockInfo.title}"`);
                        } else {
                            console.warn(`âš ï¸ PRODUCT NAME CELL NOT FOUND for ${tcin} using selector: tr[data-tcin="${tcin}"] .product-name`);
                        }
                    } else {
                        console.warn(`âš ï¸ No title provided for ${tcin}, keeping existing product name`);
                    }
                } catch (nameError) {
                    console.warn(`âš ï¸ PRODUCT NAME UPDATE FAILED: ${updateId}`, nameError);
                    // Don't fail the entire update - title is optional
                }

                // Also update product config section name if it exists (with error handling)
                try {
                    const configNameCell = document.querySelector(`div[data-tcin="${tcin}"] .product-config-name`);
                    if (configNameCell && stockInfo.title) {
                        const oldConfigName = configNameCell.textContent;
                        configNameCell.textContent = stockInfo.title;
                        console.log(`ðŸ“ CONFIG NAME UPDATED: ${updateId} - "${oldConfigName}" -> "${stockInfo.title}"`);
                    }
                } catch (configNameError) {
                    console.warn(`âš ï¸ CONFIG NAME UPDATE FAILED: ${updateId}`, configNameError);
                    // Don't fail the entire update for config name issues
                }

                // Also update catalog section name if it exists (with error handling)
                try {
                    const catalogNameCell = document.querySelector(`div[data-catalog-tcin="${tcin}"] .catalog-product-name`);
                    if (catalogNameCell && stockInfo.title && catalogNameCell.textContent.startsWith('Product ')) {
                        const oldCatalogName = catalogNameCell.textContent;
                        catalogNameCell.textContent = stockInfo.title;
                        console.log(`ðŸ“ CATALOG NAME UPDATED: ${updateId} - "${oldCatalogName}" -> "${stockInfo.title}"`);
                    }
                } catch (catalogNameError) {
                    console.warn(`âš ï¸ CATALOG NAME UPDATE FAILED: ${updateId}`, catalogNameError);
                    // Don't fail the entire update for catalog name issues
                }

                // Handle preorder status (with error handling)
                try {
                    const preorderBadge = document.querySelector(`tr[data-tcin="${tcin}"] .preorder-badge`);
                    if (preorderBadge && stockInfo.is_preorder) {
                        preorderBadge.style.display = 'inline-flex';
                        if (stockInfo.street_date) {
                            preorderBadge.title = `Pre-order - Releases ${stockInfo.street_date}`;
                        }
                        console.log(`ðŸŽ¯ PREORDER STATUS UPDATED: ${updateId} - ${stockInfo.street_date || 'No date'}`);
                    } else if (preorderBadge && !stockInfo.is_preorder) {
                        preorderBadge.style.display = 'none';
                        console.log(`ðŸŽ¯ PREORDER STATUS CLEARED: ${updateId}`);
                    }
                } catch (preorderError) {
                    console.warn(`âš ï¸ PREORDER UPDATE FAILED: ${updateId}`, preorderError);
                    // Don't fail the entire update for preorder issues
                }

                // Final validation
                const finalStatus = getStockStatusFromUI(tcin);
                if (finalStatus === expectedStatus) {
                    console.log(`âœ… STOCK UPDATE SUCCESS: ${updateId} - ${tcin} ${oldStatus} -> ${finalStatus}`);

                    // Clear any retry tracking
                    stockUpdateRetries.delete(tcin);

                    // Log significant changes
                    if (oldStatus !== finalStatus) {
                        console.log(`ðŸ”„ STOCK CHANGE CONFIRMED: ${updateId} - ${tcin} changed from ${oldStatus} to ${finalStatus}`);
                        addActivityEntryToDOM({
                            level: 'info',
                            message: `Stock status changed: ${tcin} ${oldStatus} -> ${finalStatus}`,
                            time_str: new Date().toLocaleTimeString()
                        });
                    }

                    return true;
                } else {
                    throw new Error(`Final validation failed: Expected ${expectedStatus}, got ${finalStatus}`);
                }

            } catch (error) {
                console.error(`âŒ STOCK UPDATE ATTEMPT ${attempt + 1} FAILED: ${updateId}`, error);

                // Retry logic with exponential backoff
                if (attempt < MAX_STOCK_UPDATE_RETRIES - 1) {
                    const retryDelay = STOCK_UPDATE_RETRY_DELAY * Math.pow(2, attempt);
                    console.log(`ðŸ”„ STOCK UPDATE RETRY: ${updateId} - Retrying in ${retryDelay}ms (attempt ${attempt + 2}/${MAX_STOCK_UPDATE_RETRIES})`);

                    // FIX #1: Remove async setTimeout retry - let next polling cycle retry naturally
                    // Previous code used setTimeout which returned false BEFORE retry completed
                    // This caused polling handler to think update failed when it was still pending
                    // Now we return false immediately and let the next poll cycle (5s) retry
                    console.log(`â­ï¸ STOCK UPDATE DEFERRED: ${updateId} - Will retry on next polling cycle (5s)`);
                    return false; // Let next polling cycle handle retry
                } else {
                    console.error(`âŒ STOCK UPDATE FAILED PERMANENTLY: ${updateId} - All ${MAX_STOCK_UPDATE_RETRIES} attempts failed`);

                    // Log critical failure for visibility
                    addActivityEntryToDOM({
                        level: 'error',
                        message: `Stock update failed permanently for ${tcin}: ${error.message}`,
                        time_str: new Date().toLocaleTimeString()
                    });

                    // Mark element as failed for manual attention
                    try {
                        // FIX #3: Simplified selector - more reliable, less prone to HTML structure changes
                const stockBadge = document.querySelector(`.badge[data-tcin="${tcin}"]`);
                        if (stockBadge) {
                            stockBadge.className = 'badge unknown';
                            stockBadge.textContent = 'âŒ UPDATE FAILED';
                            stockBadge.title = `Update failed: ${error.message}`;
                        }
                    } catch (fallbackError) {
                        console.error(`âŒ FALLBACK MARKING FAILED: ${updateId}`, fallbackError);
                    }

                    return false;
                }
            }
        }

        function addActivityEntryToDOM(entry) {
            // DIAGNOSTIC FIX: DOM element validation with detailed logging
            console.log('ðŸ” addActivityEntryToDOM called with:', entry);

            const logContainer = document.querySelector('.log-container');
            if (!logContainer) {
                console.error('âŒ CRITICAL: .log-container element not found in DOM!');
                console.error('   This means activity log entries cannot be displayed.');
                console.error('   Searching for alternative containers...');

                // Try to find any log-related containers
                const alternativeContainers = document.querySelectorAll('[class*="log"], [class*="activity"]');
                console.error('   Found alternative containers:', alternativeContainers);
                return;
            }

            console.log('âœ… Log container found:', logContainer);

            try {
                const entryDiv = document.createElement('div');
                entryDiv.className = `log-entry ${entry.level}`;
                entryDiv.innerHTML = `
                    <span style="opacity: 0.7;">[${entry.time_str}]</span>
                    ðŸ“‹ ${entry.message}
                `;

                console.log('âœ… Entry div created:', entryDiv);

                // Insert at the beginning
                const firstEntry = logContainer.querySelector('.log-entry');
                if (firstEntry) {
                    logContainer.insertBefore(entryDiv, firstEntry);
                    console.log('âœ… Entry inserted before first entry');
                } else {
                    logContainer.appendChild(entryDiv);
                    console.log('âœ… Entry appended (first entry in log)');
                }

                console.log(`âœ… Activity log entry successfully added to DOM. Total entries: ${logContainer.querySelectorAll('.log-entry').length}`);
            } catch (error) {
                console.error('âŒ Error creating/inserting log entry:', error);
                throw error;
            }

            // Keep only last 50 entries visible
            const entries = logContainer.querySelectorAll('.log-entry');
            if (entries.length > 50) {
                for (let i = 50; i < entries.length; i++) {
                    entries[i].remove();
                }
            }
        }

        function updateConnectionStatus(connected) {
            // Add visual indicator for connection status
            const indicator = document.getElementById('connection-status');
            if (indicator) {
                indicator.style.color = connected ? 'var(--success-color)' : 'var(--danger-color)';
                indicator.textContent = connected ? 'ðŸŸ¢ LIVE' : 'ðŸ”´ OFFLINE';
            }
        }

        // Initialize real-time updates when DOM is ready
        // CRITICAL FIX: Use DOMContentLoaded for faster initialization and await async functions
        window.addEventListener('DOMContentLoaded', async () => {
            console.log('ðŸš€ BULLETPROOF: Starting real-time dashboard...');

            try {
                // CRITICAL FIX: Await async function to ensure initial data loads before continuing
                await initializeRealTimeUpdates();
                console.log('âœ… Real-time updates initialized successfully');
            } catch (error) {
                console.error('âŒ CRITICAL: Failed to initialize real-time updates:', error);
                // Show error to user
                alert('Failed to initialize dashboard. Please refresh the page. Error: ' + error.message);
            }

            // Initialize other components
            initializeTimer();

            // FIX: Add periodic polling as safety net (15 seconds - matches backend cycle)
            // This ensures badges and activity log update even if SSE fails or timer doesn't trigger refresh
            console.log('ðŸ”„ Starting periodic polling safety net...');
            setInterval(async () => {
                try {
                    const response = await fetch('/api/current-state');
                    if (response.ok) {
                        const data = await response.json();

                        // Update stock badges
                        if (data.stock_data) {
                            Object.entries(data.stock_data).forEach(([tcin, stockInfo]) => {
                                updateStockStatus(tcin, stockInfo);
                            });
                            console.log('âœ… Periodic poll - updated stock badges');
                        }

                        // BUGFIX: Also update activity log during periodic polling
                        if (data.activity_log && Array.isArray(data.activity_log)) {
                            const logContainer = document.querySelector('.log-container');
                            if (logContainer) {
                                // Clear and reload to avoid duplicates
                                logContainer.innerHTML = '';
                                data.activity_log.forEach(entry => {
                                    addActivityEntryToDOM(entry);
                                });
                                console.log(`âœ… Periodic poll - updated activity log (${data.activity_log.length} entries)`);
                            }
                        }

                        // Update in-stock count
                        if (data.in_stock_count !== undefined) {
                            const inStockElement = document.querySelector('.status-card.warning .status-card-value');
                            if (inStockElement) {
                                inStockElement.textContent = data.in_stock_count;
                            }
                        }
                    }
                } catch (error) {
                    console.warn('âš ï¸ Periodic poll failed:', error);
                }
            }, 15000); // Every 15 seconds (matches backend monitoring cycle)
            console.log('âœ… Periodic polling safety net active (15s interval)');

            // Initialize countdowns for any existing "attempting" purchases
            initializeExistingCountdowns();

            // Start health check monitoring for sync validation
            startHealthCheckMonitoring();

            // COHESIVE SYSTEM: Initialize catalog with proper button states
            initializeCohesiveCatalogSystem();

            // Timer sync handled by initializeTimer() - no duplicate sync needed
        });

        function initializeExistingCountdowns() {
            console.log('ðŸ”„ Initializing countdowns for existing attempts...');

            // Find all products with "attempting" status and sync with server state
            const attemptingBadges = document.querySelectorAll('.badge.attempting[id^="purchase-status-"]');
            console.log(`ðŸ”„ Found ${attemptingBadges.length} attempting badges to initialize`);

            if (attemptingBadges.length === 0) {
                console.log('ðŸ”„ No attempting purchases found, initialization complete');
                return;
            }

            // Get current state from the backend for all TCINs
            fetch('/api/status')
                .then(response => response.json())
                .then(data => {
                    console.log('ðŸ”„ Got server state for initialization:', data.purchase_states);

                    attemptingBadges.forEach(badge => {
                        const tcin = badge.id.replace('purchase-status-', '');
                        const purchaseState = data.purchase_states[tcin];

                        console.log(`ðŸ”„ Initializing ${tcin}: server state =`, purchaseState);

                        if (purchaseState) {
                            const now = Date.now() / 1000;

                            if (purchaseState.status === 'attempting' && purchaseState.completes_at) {
                                const remaining = Math.max(0, Math.ceil(purchaseState.completes_at - now));

                                if (remaining > 0) {
                                    // Still attempting with time left - start countdown
                                    console.log(`ðŸ”„ Starting countdown for ${tcin}: ${remaining}s remaining`);
                                    startRealTimeCountdown(tcin, purchaseState);
                                } else {
                                    // Time expired but server hasn't updated yet - show final outcome
                                    console.log(`ðŸ”„ Time expired for ${tcin}, showing final outcome: ${purchaseState.final_outcome}`);
                                    const finalStatus = purchaseState.final_outcome || 'failed';
                                    updatePurchaseStatus(tcin, finalStatus, purchaseState);
                                }
                            } else {
                                // Already completed - update badge immediately
                                console.log(`ðŸ”„ Already completed ${tcin}: ${purchaseState.status}`);
                                updatePurchaseStatus(tcin, purchaseState.status, purchaseState);
                            }
                        } else {
                            // No server state found - reset to ready
                            console.log(`ðŸ”„ No server state for ${tcin}, resetting to ready`);
                            updatePurchaseStatus(tcin, 'ready', {});
                        }

                        // SURGICAL FIX: Force immediate update to ensure display sync
                        setTimeout(() => {
                            const badge = document.getElementById(`purchase-status-${tcin}`);
                            if (badge && badge.textContent.includes('ATTEMPTING') && !badge.textContent.includes('(')) {
                                console.log(`ðŸ”„ SURGICAL FIX: Re-syncing ${tcin} display`);
                                // Re-check state and fix display
                                if (purchaseState && purchaseState.status === 'attempting' && purchaseState.completes_at) {
                                    const nowFix = Date.now() / 1000;
                                    const remainingFix = Math.max(0, Math.ceil(purchaseState.completes_at - nowFix));
                                    if (remainingFix > 0) {
                                        startRealTimeCountdown(tcin, purchaseState);
                                    } else {
                                        const finalStatus = purchaseState.final_outcome || 'failed';
                                        updatePurchaseStatus(tcin, finalStatus, purchaseState);
                                    }
                                }
                            }
                        }, 100);
                    });
                })
                .catch(error => {
                    console.error('ðŸ”„ Failed to initialize countdowns:', error);
                    // Fallback: reset all attempting badges to ready
                    attemptingBadges.forEach(badge => {
                        const tcin = badge.id.replace('purchase-status-', '');
                        console.log(`ðŸ”„ Fallback: resetting ${tcin} to ready`);
                        updatePurchaseStatus(tcin, 'ready', {});
                    });
                });
        }

        function initializeCohesiveCatalogSystem() {
            console.log('ðŸ”— COHESIVE: Initializing unified catalog system...');

            // Get all active product TCINs from the main table
            const activeProducts = [];
            const mainTableRows = document.querySelectorAll('table tbody tr[data-tcin]');
            mainTableRows.forEach(row => {
                const tcin = row.getAttribute('data-tcin');
                const nameCell = row.querySelector('td:nth-child(2)');
                const name = nameCell ? nameCell.textContent.trim() : `Product ${tcin}`;
                activeProducts.push({ tcin, name });
            });

            console.log(`ðŸ”— COHESIVE: Found ${activeProducts.length} active products to sync with catalog`);

            // Get all existing catalog TCINs
            const existingCatalogTcins = [];
            const catalogItems = document.querySelectorAll('div[data-catalog-tcin]');
            catalogItems.forEach(item => {
                existingCatalogTcins.push(item.getAttribute('data-catalog-tcin'));
            });

            // Add missing active products to catalog
            activeProducts.forEach(product => {
                if (!existingCatalogTcins.includes(product.tcin)) {
                    console.log(`ðŸ”— COHESIVE: Adding missing active product ${product.tcin} to catalog`);
                    const catalogProduct = {
                        tcin: product.tcin,
                        name: product.name,
                        date_added: new Date().toISOString(),
                        url: `https://www.target.com/p/-/A-${product.tcin}`
                    };
                    addProductToCatalogSection(catalogProduct);
                }
            });

            // Set proper button states for all catalog items
            setTimeout(() => {
                const allCatalogItems = document.querySelectorAll('div[data-catalog-tcin]');
                allCatalogItems.forEach(item => {
                    const tcin = item.getAttribute('data-catalog-tcin');
                    const isActive = activeProducts.some(p => p.tcin === tcin);
                    updateCatalogButtonState(tcin, isActive);
                    console.log(`ðŸ”— COHESIVE: Set button state for ${tcin}: ${isActive ? 'Already Active' : 'Add to Monitor'}`);
                });

                // Update tab counters
                updateTabCounters();
                console.log('ðŸ”— COHESIVE: Catalog system initialization complete');
            }, 200);
        }

        // Clear activity logs function
        async function clearActivityLogs() {
            if (!confirm('Are you sure you want to clear all activity logs? This action cannot be undone.')) {
                return;
            }

            try {
                const button = document.getElementById('clear-logs-btn');
                const originalText = button.innerHTML;

                // Show loading state
                button.innerHTML = 'â³ Clearing...';
                button.disabled = true;

                const response = await fetch('/clear-logs', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    }
                });

                const result = await response.json();

                if (result.success) {
                    // Clear the logs from the UI immediately
                    const logContainer = document.querySelector('.log-container');
                    if (logContainer) {
                        logContainer.innerHTML = '<div class="log-entry info"><span style="opacity: 0.7;">[' +
                            new Date().toLocaleTimeString() + ']</span> ðŸ“‹ Activity logs cleared by user</div>';
                    }

                    // Show success message briefly
                    button.innerHTML = 'âœ… Cleared!';
                    setTimeout(() => {
                        button.innerHTML = originalText;
                        button.disabled = false;
                    }, 2000);
                } else {
                    throw new Error(result.error || 'Failed to clear logs');
                }
            } catch (error) {
                console.error('Error clearing logs:', error);
                alert('Failed to clear logs: ' + error.message);

                // Reset button
                const button = document.getElementById('clear-logs-btn');
                button.innerHTML = 'ðŸ—‘ï¸ Clear Logs';
                button.disabled = false;
            }
        }

        // Clean up on page unload
        window.addEventListener('beforeunload', () => {
            if (eventSource) {
                eventSource.close();
            }
            // Clear all countdown intervals
            Object.values(activeCountdowns).forEach(clearInterval);
            if (countdownInterval) {
                clearInterval(countdownInterval);
                countdownInterval = null;
            }
        });

        // FIX #2: Removed duplicate 'load' event listener (IMPORTANT)
        // This listener was causing duplicate initialization, race conditions, and duplicate SSE connections.
        // All initialization is now handled by the DOMContentLoaded listener (line 3889) which:
        // - Fires earlier (when DOM is ready)
        // - Properly awaits async functions
        // - Has error handling
        // - Calls initializeExistingCountdowns() which handles countdown initialization

    </script>
</body>
</html>
